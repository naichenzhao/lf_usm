// Code generated by the Lingua Franca compiler from:
// file://Users/naichenzhao/Desktop/BML/lf_usm/src/Main.lf
#define LOG_LEVEL 2

#include <limits.h>
#include "low_level_platform/api/low_level_platform.h"
#include "include/api/schedule.h"
#include "include/core/reactor.h"
#include "include/core/reactor_common.h"
#include "include/core/mixed_radix.h"
#include "include/core/port.h"
#include "include/core/environment.h"
int lf_reactor_c_main(int argc, const char* argv[]);
int main(void) {
   return lf_reactor_c_main(0, NULL);
}
void lf_set_default_command_line_options() {}
#include "_qdec.h"
#include "_stepper.h"
#include "_usm.h"
#include "_ffb_controller.h"
#include "_pid_controller.h"
#include "_sea_controllerx.h"
#include "_sea_controllery.h"
#include "_motor_driver.h"
#include "_switches.h"
#include "_home.h"
#include "_main_main.h"
typedef enum {
    main_main,
    _num_enclaves
} _enclave_id;
// The global array of environments associated with each enclave
environment_t envs[_num_enclaves];
// 'Create' and initialize the environments in the program
void lf_create_environments() {
    environment_init(&envs[main_main],"Main",main_main,_lf_number_of_workers,7,5,0,0,58,1,0,0,NULL);
}
// Update the pointer argument to point to the beginning of the environment array
// and return the size of that array
int _lf_get_environments(environment_t ** return_envs) {
   (*return_envs) = (environment_t *) envs;
   return _num_enclaves;
}
void _lf_initialize_trigger_objects() {
    int startup_reaction_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(startup_reaction_count);
    int shutdown_reaction_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(shutdown_reaction_count);
    int reset_reaction_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(reset_reaction_count);
    int timer_triggers_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(timer_triggers_count);
    int modal_state_reset_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(modal_state_reset_count);
    int modal_reactor_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(modal_reactor_count);
    int watchdog_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(watchdog_count);
    int bank_index;
    SUPPRESS_UNUSED_WARNING(bank_index);
    int watchdog_number = 0;
    SUPPRESS_UNUSED_WARNING(watchdog_number);
    _main_main_main_self_t* main_main_self[1];
    SUPPRESS_UNUSED_WARNING(main_main_self);
    _qdec_self_t* main_qdec_self[1];
    SUPPRESS_UNUSED_WARNING(main_qdec_self);
    _motor_driver_self_t* main_motors_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_self);
    _stepper_self_t* main_motors_stepper_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_stepper_self);
    _usm_self_t* main_motors_usm_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_usm_self);
    _sea_controllerx_self_t* main_motors_control_x_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_x_self);
    _ffb_controller_self_t* main_motors_control_x_force_control_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_x_force_control_self);
    _pid_controller_self_t* main_motors_control_x_pos_control_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_x_pos_control_self);
    _sea_controllery_self_t* main_motors_control_y_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_y_self);
    _ffb_controller_self_t* main_motors_control_y_force_control_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_y_force_control_self);
    _pid_controller_self_t* main_motors_control_y_pos_control_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_y_pos_control_self);
    _pid_controller_self_t* main_motors_control_z_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_z_self);
    _pid_controller_self_t* main_motors_control_r_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_r_self);
    _pid_controller_self_t* main_motors_control_a1_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_a1_self);
    _pid_controller_self_t* main_motors_control_a2_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_a2_self);
    _home_self_t* main_home_self[1];
    SUPPRESS_UNUSED_WARNING(main_home_self);
    _switches_self_t* main_home_homing_switches_self[1];
    SUPPRESS_UNUSED_WARNING(main_home_homing_switches_self);
    // ***** Start initializing Main of class Main
    main_main_self[0] = new__main_main();
    main_main_self[0]->base.environment = &envs[main_main];
    bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
    envs[main_main].startup_reactions[startup_reaction_count[main_main]++] = &main_main_self[0]->_lf__reaction_0;
    { // For scoping
        static int _initial = 1;
        main_main_self[0]->count = _initial;
    } // End scoping.
    // Initiaizing timer Main.motor_update.
    main_main_self[0]->_lf__motor_update.offset = MSEC(5);
    main_main_self[0]->_lf__motor_update.period = MSEC(10);
    // Associate timer with the environment of its parent
    envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_main_self[0]->_lf__motor_update;
    main_main_self[0]->_lf__motor_update.mode = NULL;
    // Initiaizing timer Main.switch_motor.
    main_main_self[0]->_lf__switch_motor.offset = MSEC(5);
    main_main_self[0]->_lf__switch_motor.period = MSEC(8000);
    // Associate timer with the environment of its parent
    envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_main_self[0]->_lf__switch_motor;
    main_main_self[0]->_lf__switch_motor.mode = NULL;
    // Initiaizing timer Main.HOME.home_pulse.
    main_main_self[0]->_lf__home_pulse.offset = MSEC(50);
    main_main_self[0]->_lf__home_pulse.period = MSEC(100);
    // Associate timer with the environment of its parent
    envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_main_self[0]->_lf__home_pulse;
    main_main_self[0]->_lf__home_pulse.mode = &main_main_self[0]->_lf__modes[0];;
    
    main_main_self[0]->_lf__reaction_0.deadline = NEVER;
    main_main_self[0]->_lf__reaction_1.deadline = NEVER;
    main_main_self[0]->_lf__reaction_2.deadline = NEVER;
    main_main_self[0]->_lf__reaction_3.deadline = NEVER;
    main_main_self[0]->_lf__reaction_4.deadline = NEVER;
    main_main_self[0]->_lf__reaction_5.deadline = NEVER;
    // Register for transition handling
    envs[main_main].modes->modal_reactor_states[modal_reactor_count[main_main]++] = &((self_base_t*)main_main_self[0])->_lf__mode_state;
    {
        _main_main_main_self_t *self = main_main_self[0];
        // ***** Start initializing Main.qdec of class QDEC
        main_qdec_self[0] = new__qdec();
        main_qdec_self[0]->base.environment = &envs[main_main];
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        main_qdec_self[0]->sample_period = MSEC(5);
        main_qdec_self[0]->_lf_qdec_out_width = 6;
        // Allocate memory for multiport output.
        main_qdec_self[0]->_lf_qdec_out = (_qdec_qdec_out_t*)lf_allocate(
                6, sizeof(_qdec_qdec_out_t),
                &main_qdec_self[0]->base.allocations); 
        main_qdec_self[0]->_lf_qdec_out_pointers = (_qdec_qdec_out_t**)lf_allocate(
                6, sizeof(_qdec_qdec_out_t*),
                &main_qdec_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 6; i++) {
                main_qdec_self[0]->_lf_qdec_out_pointers[i] = &(main_qdec_self[0]->_lf_qdec_out[i]);
        }
        main_qdec_self[0]->_lf_sea_out_width = 6;
        // Allocate memory for multiport output.
        main_qdec_self[0]->_lf_sea_out = (_qdec_sea_out_t*)lf_allocate(
                6, sizeof(_qdec_sea_out_t),
                &main_qdec_self[0]->base.allocations); 
        main_qdec_self[0]->_lf_sea_out_pointers = (_qdec_sea_out_t**)lf_allocate(
                6, sizeof(_qdec_sea_out_t*),
                &main_qdec_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 6; i++) {
                main_qdec_self[0]->_lf_sea_out_pointers[i] = &(main_qdec_self[0]->_lf_sea_out[i]);
        }
        // width of -2 indicates that it is not a multiport.
        main_qdec_self[0]->_lf_reset_qdec_width = -2;
        envs[main_main].startup_reactions[startup_reaction_count[main_main]++] = &main_qdec_self[0]->_lf__reaction_0;
        // Initiaizing timer Main.qdec.trigger.
        main_qdec_self[0]->_lf__trigger.offset = 0;
        main_qdec_self[0]->_lf__trigger.period = MSEC(5);
        // Associate timer with the environment of its parent
        envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_qdec_self[0]->_lf__trigger;
        main_qdec_self[0]->_lf__trigger.mode = NULL;
    
        main_qdec_self[0]->_lf__reaction_0.deadline = NEVER;
        main_qdec_self[0]->_lf__reaction_1.deadline = NEVER;
        main_qdec_self[0]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing Main.qdec
    }
    {
        _main_main_main_self_t *self = main_main_self[0];
        // ***** Start initializing Main.motors of class Motor_Driver
        main_motors_self[0] = new__motor_driver();
        main_motors_self[0]->base.environment = &envs[main_main];
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        main_motors_self[0]->refresh_period = MSEC(5);
        main_motors_self[0]->_lf_target_sel_width = 6;
        // Allocate memory for multiport inputs.
        main_motors_self[0]->_lf_target_sel = (_motor_driver_target_sel_t**)lf_allocate(
                6, sizeof(_motor_driver_target_sel_t*),
                &main_motors_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 6; i++) {
            main_motors_self[0]->_lf_target_sel[i] = &main_motors_self[0]->_lf_default__target_sel;
        }
        main_motors_self[0]->_lf_target_speed_width = 6;
        // Allocate memory for multiport inputs.
        main_motors_self[0]->_lf_target_speed = (_motor_driver_target_speed_t**)lf_allocate(
                6, sizeof(_motor_driver_target_speed_t*),
                &main_motors_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 6; i++) {
            main_motors_self[0]->_lf_target_speed[i] = &main_motors_self[0]->_lf_default__target_speed;
        }
        main_motors_self[0]->_lf_target_pos_width = 6;
        // Allocate memory for multiport inputs.
        main_motors_self[0]->_lf_target_pos = (_motor_driver_target_pos_t**)lf_allocate(
                6, sizeof(_motor_driver_target_pos_t*),
                &main_motors_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 6; i++) {
            main_motors_self[0]->_lf_target_pos[i] = &main_motors_self[0]->_lf_default__target_pos;
        }
        main_motors_self[0]->_lf_qdec_current_width = 6;
        // Allocate memory for multiport inputs.
        main_motors_self[0]->_lf_qdec_current = (_motor_driver_qdec_current_t**)lf_allocate(
                6, sizeof(_motor_driver_qdec_current_t*),
                &main_motors_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 6; i++) {
            main_motors_self[0]->_lf_qdec_current[i] = &main_motors_self[0]->_lf_default__qdec_current;
        }
        main_motors_self[0]->_lf_qdec_sea_width = 6;
        // Allocate memory for multiport inputs.
        main_motors_self[0]->_lf_qdec_sea = (_motor_driver_qdec_sea_t**)lf_allocate(
                6, sizeof(_motor_driver_qdec_sea_t*),
                &main_motors_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 6; i++) {
            main_motors_self[0]->_lf_qdec_sea[i] = &main_motors_self[0]->_lf_default__qdec_sea;
        }
        { // For scoping
            static bool _initial[6] = {0,0,0,0,0,0};
            main_motors_self[0]->sel = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[6] = {0,0,0,0,0,0};
            main_motors_self[0]->speed_spc = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[6] = {0,0,0,0,0,0};
            main_motors_self[0]->speed_posc = _initial;
        } // End scoping.
        // Initiaizing timer Main.motors.trigger.
        main_motors_self[0]->_lf__trigger.offset = 0;
        main_motors_self[0]->_lf__trigger.period = MSEC(5);
        // Associate timer with the environment of its parent
        envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_motors_self[0]->_lf__trigger;
        main_motors_self[0]->_lf__trigger.mode = NULL;
    
        main_motors_self[0]->_lf__reaction_0.deadline = NEVER;
        main_motors_self[0]->_lf__reaction_1.deadline = NEVER;
        main_motors_self[0]->_lf__reaction_2.deadline = NEVER;
        {
            _motor_driver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.stepper of class Stepper
            main_motors_stepper_self[0] = new__stepper();
            main_motors_stepper_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            // width of -2 indicates that it is not a multiport.
            main_motors_stepper_self[0]->_lf_set_speed_0_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_stepper_self[0]->_lf_set_speed_1_width = -2;
            envs[main_main].startup_reactions[startup_reaction_count[main_main]++] = &main_motors_stepper_self[0]->_lf__reaction_0;
    
            main_motors_stepper_self[0]->_lf__reaction_0.deadline = NEVER;
            main_motors_stepper_self[0]->_lf__reaction_1.deadline = NEVER;
            //***** End initializing Main.motors.stepper
        }
        {
            _motor_driver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.usm of class USM
            main_motors_usm_self[0] = new__usm();
            main_motors_usm_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            // width of -2 indicates that it is not a multiport.
            main_motors_usm_self[0]->_lf_set_speed_2_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_usm_self[0]->_lf_set_speed_3_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_usm_self[0]->_lf_set_speed_4_width = -2;
            envs[main_main].startup_reactions[startup_reaction_count[main_main]++] = &main_motors_usm_self[0]->_lf__reaction_0;
    
            main_motors_usm_self[0]->_lf__reaction_0.deadline = NEVER;
            main_motors_usm_self[0]->_lf__reaction_1.deadline = NEVER;
            //***** End initializing Main.motors.usm
        }
        {
            _motor_driver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_x of class SEA_ControllerX
            main_motors_control_x_self[0] = new__sea_controllerx();
            main_motors_control_x_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_x_self[0]->Kp = 10;
            main_motors_control_x_self[0]->Ki = 5;
            main_motors_control_x_self[0]->Kd = -2;
            main_motors_control_x_self[0]->Ks = 1000;
            main_motors_control_x_self[0]->SLIM = 0.008;
            main_motors_control_x_self[0]->SEA_LIM = 0.1;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_x_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_x_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_x_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_x_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static int _initial = 0;
                main_motors_control_x_self[0]->fsm_state = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_x_self[0]->last_target = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_x_self[0]->last_sea = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_x_self[0]->last_out = _initial;
            } // End scoping.
            { // For scoping
                static int _initial = 0;
                main_motors_control_x_self[0]->cycle_count = _initial;
            } // End scoping.
            { // For scoping
                static bool _initial = true;
                main_motors_control_x_self[0]->print_data = _initial;
            } // End scoping.
    
            main_motors_control_x_self[0]->_lf__reaction_0.deadline = NEVER;
            main_motors_control_x_self[0]->_lf__reaction_1.deadline = NEVER;
            {
                _sea_controllerx_self_t *self = main_motors_control_x_self[0];
                // ***** Start initializing Main.motors.control_x.force_control of class FFB_Controller
                main_motors_control_x_force_control_self[0] = new__ffb_controller();
                main_motors_control_x_force_control_self[0]->base.environment = &envs[main_main];
                bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
                main_motors_control_x_force_control_self[0]->Ks = main_motors_control_x_self[0]->Ks;
                main_motors_control_x_force_control_self[0]->SLIM = main_motors_control_x_self[0]->SLIM;
                main_motors_control_x_force_control_self[0]->D_LIM = 0.002;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_x_force_control_self[0]->_lf_out_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_x_force_control_self[0]->_lf_current_pos_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_x_force_control_self[0]->_lf_sea_pos_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_x_force_control_self[0]->_lf_target_pos_width = -2;
                { // For scoping
                    static float _initial = 0;
                    main_motors_control_x_force_control_self[0]->last_sea = _initial;
                } // End scoping.
    
                main_motors_control_x_force_control_self[0]->_lf__reaction_0.deadline = NEVER;
                //***** End initializing Main.motors.control_x.force_control
            }
            {
                _sea_controllerx_self_t *self = main_motors_control_x_self[0];
                // ***** Start initializing Main.motors.control_x.pos_control of class PID_Controller
                main_motors_control_x_pos_control_self[0] = new__pid_controller();
                main_motors_control_x_pos_control_self[0]->base.environment = &envs[main_main];
                bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
                main_motors_control_x_pos_control_self[0]->Kp = main_motors_control_x_self[0]->Kp;
                main_motors_control_x_pos_control_self[0]->Ki = main_motors_control_x_self[0]->Ki;
                main_motors_control_x_pos_control_self[0]->Kd = main_motors_control_x_self[0]->Kd;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_x_pos_control_self[0]->_lf_out_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_x_pos_control_self[0]->_lf_current_pos_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_x_pos_control_self[0]->_lf_sea_pos_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_x_pos_control_self[0]->_lf_target_pos_width = -2;
                { // For scoping
                    static float _initial = 0;
                    main_motors_control_x_pos_control_self[0]->last_pos = _initial;
                } // End scoping.
                main_motors_control_x_pos_control_self[0]->prev_time = 0;
                { // For scoping
                    static float _initial = 0.9;
                    main_motors_control_x_pos_control_self[0]->Kw = _initial;
                } // End scoping.
                { // For scoping
                    static float _initial = 0;
                    main_motors_control_x_pos_control_self[0]->error_i = _initial;
                } // End scoping.
    
                main_motors_control_x_pos_control_self[0]->_lf__reaction_0.deadline = NEVER;
                //***** End initializing Main.motors.control_x.pos_control
            }
            //***** End initializing Main.motors.control_x
        }
        {
            _motor_driver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_y of class SEA_ControllerY
            main_motors_control_y_self[0] = new__sea_controllery();
            main_motors_control_y_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_y_self[0]->Kp = 8;
            main_motors_control_y_self[0]->Ki = 5;
            main_motors_control_y_self[0]->Kd = -2;
            main_motors_control_y_self[0]->Ks = 1800;
            main_motors_control_y_self[0]->SLIM = 0.002;
            main_motors_control_y_self[0]->SEA_LIM = 0.05;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_y_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_y_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_y_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_y_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static int _initial = 0;
                main_motors_control_y_self[0]->fsm_state = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_y_self[0]->last_target = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_y_self[0]->last_sea = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_y_self[0]->last_out = _initial;
            } // End scoping.
            { // For scoping
                static int _initial = 0;
                main_motors_control_y_self[0]->cycle_count = _initial;
            } // End scoping.
            { // For scoping
                static bool _initial = true;
                main_motors_control_y_self[0]->print_data = _initial;
            } // End scoping.
    
            main_motors_control_y_self[0]->_lf__reaction_0.deadline = NEVER;
            main_motors_control_y_self[0]->_lf__reaction_1.deadline = NEVER;
            {
                _sea_controllery_self_t *self = main_motors_control_y_self[0];
                // ***** Start initializing Main.motors.control_y.force_control of class FFB_Controller
                main_motors_control_y_force_control_self[0] = new__ffb_controller();
                main_motors_control_y_force_control_self[0]->base.environment = &envs[main_main];
                bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
                main_motors_control_y_force_control_self[0]->Ks = main_motors_control_y_self[0]->Ks;
                main_motors_control_y_force_control_self[0]->SLIM = main_motors_control_y_self[0]->SLIM;
                main_motors_control_y_force_control_self[0]->D_LIM = 0.0004;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_y_force_control_self[0]->_lf_out_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_y_force_control_self[0]->_lf_current_pos_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_y_force_control_self[0]->_lf_sea_pos_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_y_force_control_self[0]->_lf_target_pos_width = -2;
                { // For scoping
                    static float _initial = 0;
                    main_motors_control_y_force_control_self[0]->last_sea = _initial;
                } // End scoping.
    
                main_motors_control_y_force_control_self[0]->_lf__reaction_0.deadline = NEVER;
                //***** End initializing Main.motors.control_y.force_control
            }
            {
                _sea_controllery_self_t *self = main_motors_control_y_self[0];
                // ***** Start initializing Main.motors.control_y.pos_control of class PID_Controller
                main_motors_control_y_pos_control_self[0] = new__pid_controller();
                main_motors_control_y_pos_control_self[0]->base.environment = &envs[main_main];
                bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
                main_motors_control_y_pos_control_self[0]->Kp = main_motors_control_y_self[0]->Kp;
                main_motors_control_y_pos_control_self[0]->Ki = main_motors_control_y_self[0]->Ki;
                main_motors_control_y_pos_control_self[0]->Kd = main_motors_control_y_self[0]->Kd;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_y_pos_control_self[0]->_lf_out_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_y_pos_control_self[0]->_lf_current_pos_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_y_pos_control_self[0]->_lf_sea_pos_width = -2;
                // width of -2 indicates that it is not a multiport.
                main_motors_control_y_pos_control_self[0]->_lf_target_pos_width = -2;
                { // For scoping
                    static float _initial = 0;
                    main_motors_control_y_pos_control_self[0]->last_pos = _initial;
                } // End scoping.
                main_motors_control_y_pos_control_self[0]->prev_time = 0;
                { // For scoping
                    static float _initial = 0.9;
                    main_motors_control_y_pos_control_self[0]->Kw = _initial;
                } // End scoping.
                { // For scoping
                    static float _initial = 0;
                    main_motors_control_y_pos_control_self[0]->error_i = _initial;
                } // End scoping.
    
                main_motors_control_y_pos_control_self[0]->_lf__reaction_0.deadline = NEVER;
                //***** End initializing Main.motors.control_y.pos_control
            }
            //***** End initializing Main.motors.control_y
        }
        {
            _motor_driver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_z of class PID_Controller
            main_motors_control_z_self[0] = new__pid_controller();
            main_motors_control_z_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_z_self[0]->Kp = 30;
            main_motors_control_z_self[0]->Ki = 5;
            main_motors_control_z_self[0]->Kd = 10;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_z_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_z_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_z_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_z_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_z_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_z_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_z_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_z_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_z_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_z
        }
        {
            _motor_driver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_r of class PID_Controller
            main_motors_control_r_self[0] = new__pid_controller();
            main_motors_control_r_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_r_self[0]->Kp = -1;
            main_motors_control_r_self[0]->Ki = 0;
            main_motors_control_r_self[0]->Kd = 0.1;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_r_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_r_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_r_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_r_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_r_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_r_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_r_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_r_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_r_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_r
        }
        {
            _motor_driver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_a1 of class PID_Controller
            main_motors_control_a1_self[0] = new__pid_controller();
            main_motors_control_a1_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_a1_self[0]->Kp = 10;
            main_motors_control_a1_self[0]->Ki = 0;
            main_motors_control_a1_self[0]->Kd = 3;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_a1_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_a1_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_a1_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_a1_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_a1_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_a1_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_a1_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_a1_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_a1_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_a1
        }
        {
            _motor_driver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_a2 of class PID_Controller
            main_motors_control_a2_self[0] = new__pid_controller();
            main_motors_control_a2_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_a2_self[0]->Kp = 10;
            main_motors_control_a2_self[0]->Ki = 0;
            main_motors_control_a2_self[0]->Kd = 3;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_a2_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_a2_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_a2_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_a2_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_a2_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_a2_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_a2_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_a2_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_a2_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_a2
        }
        //***** End initializing Main.motors
    }
    {
        _main_main_main_self_t *self = main_main_self[0];
        // ***** Start initializing Main.home of class Home
        main_home_self[0] = new__home();
        main_home_self[0]->base.environment = &envs[main_main];
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        main_home_self[0]->sample_period = MSEC(15);
        main_home_self[0]->_lf_motor_speed_width = 6;
        // Allocate memory for multiport output.
        main_home_self[0]->_lf_motor_speed = (_home_motor_speed_t*)lf_allocate(
                6, sizeof(_home_motor_speed_t),
                &main_home_self[0]->base.allocations); 
        main_home_self[0]->_lf_motor_speed_pointers = (_home_motor_speed_t**)lf_allocate(
                6, sizeof(_home_motor_speed_t*),
                &main_home_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 6; i++) {
                main_home_self[0]->_lf_motor_speed_pointers[i] = &(main_home_self[0]->_lf_motor_speed[i]);
        }
        main_home_self[0]->_lf_current_pos_width = 6;
        // Allocate memory for multiport inputs.
        main_home_self[0]->_lf_current_pos = (_home_current_pos_t**)lf_allocate(
                6, sizeof(_home_current_pos_t*),
                &main_home_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 6; i++) {
            main_home_self[0]->_lf_current_pos[i] = &main_home_self[0]->_lf_default__current_pos;
        }
        main_home_self[0]->_lf_sea_pos_width = 6;
        // Allocate memory for multiport inputs.
        main_home_self[0]->_lf_sea_pos = (_home_sea_pos_t**)lf_allocate(
                6, sizeof(_home_sea_pos_t*),
                &main_home_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 6; i++) {
            main_home_self[0]->_lf_sea_pos[i] = &main_home_self[0]->_lf_default__sea_pos;
        }
        { // For scoping
            static int _initial[6] = {0,0,0,0,0,0};
            main_home_self[0]->is_home = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[6] = {-20,-10,100,0,30,30};
            main_home_self[0]->home_speed = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[6] = {0,0,0,0,0,0};
            main_home_self[0]->last_pos = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[6] = {0,0,0,0,0,0};
            main_home_self[0]->last_sea = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[6] = {0,0,0,0,0,0};
            main_home_self[0]->pos_diff = _initial;
        } // End scoping.
        { // For scoping
            static int _initial[6] = {0,0,0,0,0,0};
            main_home_self[0]->diffzero_cnt = _initial;
        } // End scoping.
        { // For scoping
            static int _initial = 0;
            main_home_self[0]->update_cnt = _initial;
        } // End scoping.
        // Initiaizing timer Main.home.trigger.
        main_home_self[0]->_lf__trigger.offset = 0;
        main_home_self[0]->_lf__trigger.period = MSEC(15);
        // Associate timer with the environment of its parent
        envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_home_self[0]->_lf__trigger;
        main_home_self[0]->_lf__trigger.mode = NULL;
    
        main_home_self[0]->_lf__reaction_0.deadline = NEVER;
        {
            _home_self_t *self = main_home_self[0];
            // ***** Start initializing Main.home.homing_switches of class Switches
            main_home_homing_switches_self[0] = new__switches();
            main_home_homing_switches_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_home_homing_switches_self[0]->sample_period = MSEC(100);
            main_home_homing_switches_self[0]->_lf_read_width = 6;
            // Allocate memory for multiport output.
            main_home_homing_switches_self[0]->_lf_read = (_switches_read_t*)lf_allocate(
                    6, sizeof(_switches_read_t),
                    &main_home_homing_switches_self[0]->base.allocations); 
            main_home_homing_switches_self[0]->_lf_read_pointers = (_switches_read_t**)lf_allocate(
                    6, sizeof(_switches_read_t*),
                    &main_home_homing_switches_self[0]->base.allocations); 
            // Assign each output port pointer to be used in
            // reactions to facilitate user access to output ports
            for(int i=0; i < 6; i++) {
                    main_home_homing_switches_self[0]->_lf_read_pointers[i] = &(main_home_homing_switches_self[0]->_lf_read[i]);
            }
            envs[main_main].startup_reactions[startup_reaction_count[main_main]++] = &main_home_homing_switches_self[0]->_lf__reaction_0;
            // Initiaizing timer Main.home.homing_switches.trigger.
            main_home_homing_switches_self[0]->_lf__trigger.offset = 0;
            main_home_homing_switches_self[0]->_lf__trigger.period = MSEC(100);
            // Associate timer with the environment of its parent
            envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_home_homing_switches_self[0]->_lf__trigger;
            main_home_homing_switches_self[0]->_lf__trigger.mode = NULL;
    
            main_home_homing_switches_self[0]->_lf__reaction_0.deadline = NEVER;
            main_home_homing_switches_self[0]->_lf__reaction_1.deadline = NEVER;
            //***** End initializing Main.home.homing_switches
        }
        //***** End initializing Main.home
    }
    //***** End initializing Main
    // **** Start deferred initialize for Main
    {
        // A reaction writes to a multiport of a child. Allocate memory.
        {
            main_main_self[0]->_lf_motors.target_pos_width = 6;
            // Allocate memory to store output of reaction feeding 
            // a multiport input of a contained reactor.
            main_main_self[0]->_lf_motors.target_pos = (_motor_driver_target_pos_t**)lf_allocate(
                    6, sizeof(_motor_driver_target_pos_t*),
                    &main_main_self[0]->base.allocations); 
            for (int i = 0; i < 6; i++) {
                main_main_self[0]->_lf_motors.target_pos[i] = (_motor_driver_target_pos_t*)lf_allocate(
                        1, sizeof(_motor_driver_target_pos_t),
                        &main_main_self[0]->base.allocations); 
            }
        }
        // A reaction writes to a multiport of a child. Allocate memory.
        {
            main_main_self[0]->_lf_motors.target_sel_width = 6;
            // Allocate memory to store output of reaction feeding 
            // a multiport input of a contained reactor.
            main_main_self[0]->_lf_motors.target_sel = (_motor_driver_target_sel_t**)lf_allocate(
                    6, sizeof(_motor_driver_target_sel_t*),
                    &main_main_self[0]->base.allocations); 
            for (int i = 0; i < 6; i++) {
                main_main_self[0]->_lf_motors.target_sel[i] = (_motor_driver_target_sel_t*)lf_allocate(
                        1, sizeof(_motor_driver_target_sel_t),
                        &main_main_self[0]->base.allocations); 
            }
        }
        // A reaction writes to a multiport of a child. Allocate memory.
        {
            main_main_self[0]->_lf_motors.target_speed_width = 6;
            // Allocate memory to store output of reaction feeding 
            // a multiport input of a contained reactor.
            main_main_self[0]->_lf_motors.target_speed = (_motor_driver_target_speed_t**)lf_allocate(
                    6, sizeof(_motor_driver_target_speed_t*),
                    &main_main_self[0]->base.allocations); 
            for (int i = 0; i < 6; i++) {
                main_main_self[0]->_lf_motors.target_speed[i] = (_motor_driver_target_speed_t*)lf_allocate(
                        1, sizeof(_motor_driver_target_speed_t),
                        &main_main_self[0]->base.allocations); 
            }
        }
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_1 of Main.
        main_main_self[0]->_lf__reaction_0.num_outputs = 0;
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
        }
        
        // ** End initialization for reaction 0 of Main
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_2 of Main.
        main_main_self[0]->_lf__reaction_1.num_outputs = 6;
        // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
        // struct for this reaction.
        main_main_self[0]->_lf__reaction_1.triggers = (trigger_t***)lf_allocate(
                6, sizeof(trigger_t**),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_1.triggered_sizes = (int*)lf_allocate(
                6, sizeof(int),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_1.output_produced = (bool**)lf_allocate(
                6, sizeof(bool*),
                &main_main_self[0]->base.allocations);
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            // Reaction writes to an input of a contained reactor.
            {
                for (int i = 0; i < 6; i++) {
                    main_main_self[0]->_lf__reaction_1.output_produced[i + count]
                            = &main_main_self[0]->_lf_motors.target_pos[i]->is_present;
                }
                count += 6;
            }
        }
        
        // ** End initialization for reaction 1 of Main
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_3 of Main.
        main_main_self[0]->_lf__reaction_2.num_outputs = 1;
        // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
        // struct for this reaction.
        main_main_self[0]->_lf__reaction_2.triggers = (trigger_t***)lf_allocate(
                1, sizeof(trigger_t**),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_2.triggered_sizes = (int*)lf_allocate(
                1, sizeof(int),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_2.output_produced = (bool**)lf_allocate(
                1, sizeof(bool*),
                &main_main_self[0]->base.allocations);
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            // Reaction writes to an input of a contained reactor.
            {
                main_main_self[0]->_lf__reaction_2.output_produced[count++] = &main_main_self[0]->_lf_qdec.reset_qdec.is_present;
            }
        }
        
        // ** End initialization for reaction 2 of Main
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_4 of Main.
        main_main_self[0]->_lf__reaction_3.num_outputs = 0;
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
        }
        
        // ** End initialization for reaction 3 of Main
        // Allocate memory to store pointers to the multiport output motor_speed 
        // of a contained reactor Main.home
        {
            main_main_self[0]->_lf_home.motor_speed_width = 6;
            main_main_self[0]->_lf_home.motor_speed
                    = (_home_motor_speed_t**)lf_allocate(
                            6, sizeof(_home_motor_speed_t*),
                            &main_main_self[0]->base.allocations); 
        }
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_5 of Main.
        main_main_self[0]->_lf__reaction_4.num_outputs = 12;
        // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
        // struct for this reaction.
        main_main_self[0]->_lf__reaction_4.triggers = (trigger_t***)lf_allocate(
                12, sizeof(trigger_t**),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_4.triggered_sizes = (int*)lf_allocate(
                12, sizeof(int),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_4.output_produced = (bool**)lf_allocate(
                12, sizeof(bool*),
                &main_main_self[0]->base.allocations);
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            // Reaction writes to an input of a contained reactor.
            {
                for (int i = 0; i < 6; i++) {
                    main_main_self[0]->_lf__reaction_4.output_produced[i + count]
                            = &main_main_self[0]->_lf_motors.target_sel[i]->is_present;
                }
                count += 6;
            }
            // Reaction writes to an input of a contained reactor.
            {
                for (int i = 0; i < 6; i++) {
                    main_main_self[0]->_lf__reaction_4.output_produced[i + count]
                            = &main_main_self[0]->_lf_motors.target_speed[i]->is_present;
                }
                count += 6;
            }
        }
        
        // ** End initialization for reaction 4 of Main
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_6 of Main.
        main_main_self[0]->_lf__reaction_5.num_outputs = 12;
        // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
        // struct for this reaction.
        main_main_self[0]->_lf__reaction_5.triggers = (trigger_t***)lf_allocate(
                12, sizeof(trigger_t**),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_5.triggered_sizes = (int*)lf_allocate(
                12, sizeof(int),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_5.output_produced = (bool**)lf_allocate(
                12, sizeof(bool*),
                &main_main_self[0]->base.allocations);
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            // Reaction writes to an input of a contained reactor.
            {
                for (int i = 0; i < 6; i++) {
                    main_main_self[0]->_lf__reaction_5.output_produced[i + count]
                            = &main_main_self[0]->_lf_motors.target_sel[i]->is_present;
                }
                count += 6;
            }
            // Reaction writes to an input of a contained reactor.
            {
                for (int i = 0; i < 6; i++) {
                    main_main_self[0]->_lf__reaction_5.output_produced[i + count]
                            = &main_main_self[0]->_lf_motors.target_speed[i]->is_present;
                }
                count += 6;
            }
        }
        
        // ** End initialization for reaction 5 of Main
    
        // **** Start deferred initialize for Main.qdec
        {
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of Main.qdec.
            main_qdec_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of Main.qdec
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of Main.qdec.
            main_qdec_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of Main.qdec
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of Main.qdec.
            main_qdec_self[0]->_lf__reaction_2.num_outputs = 12;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            main_qdec_self[0]->_lf__reaction_2.triggers = (trigger_t***)lf_allocate(
                    12, sizeof(trigger_t**),
                    &main_qdec_self[0]->base.allocations);
            main_qdec_self[0]->_lf__reaction_2.triggered_sizes = (int*)lf_allocate(
                    12, sizeof(int),
                    &main_qdec_self[0]->base.allocations);
            main_qdec_self[0]->_lf__reaction_2.output_produced = (bool**)lf_allocate(
                    12, sizeof(bool*),
                    &main_qdec_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    for (int i = 0; i < 6; i++) {
                        main_qdec_self[0]->_lf__reaction_2.output_produced[i + count]
                                = &main_qdec_self[0]->_lf_qdec_out[i].is_present;
                    }
                    count += 6;
                }
                {
                    for (int i = 0; i < 6; i++) {
                        main_qdec_self[0]->_lf__reaction_2.output_produced[i + count]
                                = &main_qdec_self[0]->_lf_sea_out[i].is_present;
                    }
                    count += 6;
                }
            }
            
            // ** End initialization for reaction 2 of Main.qdec
        
        }
        // **** End of deferred initialize for Main.qdec
        // **** Start deferred initialize for Main.motors
        {
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of Main.motors.
            main_motors_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of Main.motors
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of Main.motors.
            main_motors_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of Main.motors
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of Main.motors.
            main_motors_self[0]->_lf__reaction_2.num_outputs = 5;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            main_motors_self[0]->_lf__reaction_2.triggers = (trigger_t***)lf_allocate(
                    5, sizeof(trigger_t**),
                    &main_motors_self[0]->base.allocations);
            main_motors_self[0]->_lf__reaction_2.triggered_sizes = (int*)lf_allocate(
                    5, sizeof(int),
                    &main_motors_self[0]->base.allocations);
            main_motors_self[0]->_lf__reaction_2.output_produced = (bool**)lf_allocate(
                    5, sizeof(bool*),
                    &main_motors_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_stepper.set_speed_0.is_present;
                }
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_stepper.set_speed_1.is_present;
                }
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_usm.set_speed_2.is_present;
                }
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_usm.set_speed_3.is_present;
                }
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_usm.set_speed_4.is_present;
                }
            }
            
            // ** End initialization for reaction 2 of Main.motors
        
            // **** Start deferred initialize for Main.motors.stepper
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.stepper.
                main_motors_stepper_self[0]->_lf__reaction_0.num_outputs = 0;
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                }
                
                // ** End initialization for reaction 0 of Main.motors.stepper
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_2 of Main.motors.stepper.
                main_motors_stepper_self[0]->_lf__reaction_1.num_outputs = 0;
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                }
                
                // ** End initialization for reaction 1 of Main.motors.stepper
            
            }
            // **** End of deferred initialize for Main.motors.stepper
            // **** Start deferred initialize for Main.motors.usm
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.usm.
                main_motors_usm_self[0]->_lf__reaction_0.num_outputs = 0;
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                }
                
                // ** End initialization for reaction 0 of Main.motors.usm
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_2 of Main.motors.usm.
                main_motors_usm_self[0]->_lf__reaction_1.num_outputs = 0;
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                }
                
                // ** End initialization for reaction 1 of Main.motors.usm
            
            }
            // **** End of deferred initialize for Main.motors.usm
            // **** Start deferred initialize for Main.motors.control_x
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_x.
                main_motors_control_x_self[0]->_lf__reaction_0.num_outputs = 0;
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_x
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_2 of Main.motors.control_x.
                main_motors_control_x_self[0]->_lf__reaction_1.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_x_self[0]->_lf__reaction_1.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_x_self[0]->base.allocations);
                main_motors_control_x_self[0]->_lf__reaction_1.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_x_self[0]->base.allocations);
                main_motors_control_x_self[0]->_lf__reaction_1.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_x_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_x_self[0]->_lf__reaction_1.output_produced[count++] = &main_motors_control_x_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 1 of Main.motors.control_x
            
                // **** Start deferred initialize for Main.motors.control_x.force_control
                {
                
                    // Total number of outputs (single ports and multiport channels)
                    // produced by reaction_1 of Main.motors.control_x.force_control.
                    main_motors_control_x_force_control_self[0]->_lf__reaction_0.num_outputs = 1;
                    // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                    // struct for this reaction.
                    main_motors_control_x_force_control_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                            1, sizeof(trigger_t**),
                            &main_motors_control_x_force_control_self[0]->base.allocations);
                    main_motors_control_x_force_control_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                            1, sizeof(int),
                            &main_motors_control_x_force_control_self[0]->base.allocations);
                    main_motors_control_x_force_control_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                            1, sizeof(bool*),
                            &main_motors_control_x_force_control_self[0]->base.allocations);
                    {
                        int count = 0; SUPPRESS_UNUSED_WARNING(count);
                        {
                            main_motors_control_x_force_control_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_x_force_control_self[0]->_lf_out.is_present;
                        }
                    }
                    
                    // ** End initialization for reaction 0 of Main.motors.control_x.force_control
                
                }
                // **** End of deferred initialize for Main.motors.control_x.force_control
                // **** Start deferred initialize for Main.motors.control_x.pos_control
                {
                
                    // Total number of outputs (single ports and multiport channels)
                    // produced by reaction_1 of Main.motors.control_x.pos_control.
                    main_motors_control_x_pos_control_self[0]->_lf__reaction_0.num_outputs = 1;
                    // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                    // struct for this reaction.
                    main_motors_control_x_pos_control_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                            1, sizeof(trigger_t**),
                            &main_motors_control_x_pos_control_self[0]->base.allocations);
                    main_motors_control_x_pos_control_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                            1, sizeof(int),
                            &main_motors_control_x_pos_control_self[0]->base.allocations);
                    main_motors_control_x_pos_control_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                            1, sizeof(bool*),
                            &main_motors_control_x_pos_control_self[0]->base.allocations);
                    {
                        int count = 0; SUPPRESS_UNUSED_WARNING(count);
                        {
                            main_motors_control_x_pos_control_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_x_pos_control_self[0]->_lf_out.is_present;
                        }
                    }
                    
                    // ** End initialization for reaction 0 of Main.motors.control_x.pos_control
                
                }
                // **** End of deferred initialize for Main.motors.control_x.pos_control
            }
            // **** End of deferred initialize for Main.motors.control_x
            // **** Start deferred initialize for Main.motors.control_y
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_y.
                main_motors_control_y_self[0]->_lf__reaction_0.num_outputs = 0;
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_y
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_2 of Main.motors.control_y.
                main_motors_control_y_self[0]->_lf__reaction_1.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_y_self[0]->_lf__reaction_1.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_y_self[0]->base.allocations);
                main_motors_control_y_self[0]->_lf__reaction_1.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_y_self[0]->base.allocations);
                main_motors_control_y_self[0]->_lf__reaction_1.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_y_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_y_self[0]->_lf__reaction_1.output_produced[count++] = &main_motors_control_y_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 1 of Main.motors.control_y
            
                // **** Start deferred initialize for Main.motors.control_y.force_control
                {
                
                    // Total number of outputs (single ports and multiport channels)
                    // produced by reaction_1 of Main.motors.control_y.force_control.
                    main_motors_control_y_force_control_self[0]->_lf__reaction_0.num_outputs = 1;
                    // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                    // struct for this reaction.
                    main_motors_control_y_force_control_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                            1, sizeof(trigger_t**),
                            &main_motors_control_y_force_control_self[0]->base.allocations);
                    main_motors_control_y_force_control_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                            1, sizeof(int),
                            &main_motors_control_y_force_control_self[0]->base.allocations);
                    main_motors_control_y_force_control_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                            1, sizeof(bool*),
                            &main_motors_control_y_force_control_self[0]->base.allocations);
                    {
                        int count = 0; SUPPRESS_UNUSED_WARNING(count);
                        {
                            main_motors_control_y_force_control_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_y_force_control_self[0]->_lf_out.is_present;
                        }
                    }
                    
                    // ** End initialization for reaction 0 of Main.motors.control_y.force_control
                
                }
                // **** End of deferred initialize for Main.motors.control_y.force_control
                // **** Start deferred initialize for Main.motors.control_y.pos_control
                {
                
                    // Total number of outputs (single ports and multiport channels)
                    // produced by reaction_1 of Main.motors.control_y.pos_control.
                    main_motors_control_y_pos_control_self[0]->_lf__reaction_0.num_outputs = 1;
                    // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                    // struct for this reaction.
                    main_motors_control_y_pos_control_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                            1, sizeof(trigger_t**),
                            &main_motors_control_y_pos_control_self[0]->base.allocations);
                    main_motors_control_y_pos_control_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                            1, sizeof(int),
                            &main_motors_control_y_pos_control_self[0]->base.allocations);
                    main_motors_control_y_pos_control_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                            1, sizeof(bool*),
                            &main_motors_control_y_pos_control_self[0]->base.allocations);
                    {
                        int count = 0; SUPPRESS_UNUSED_WARNING(count);
                        {
                            main_motors_control_y_pos_control_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_y_pos_control_self[0]->_lf_out.is_present;
                        }
                    }
                    
                    // ** End initialization for reaction 0 of Main.motors.control_y.pos_control
                
                }
                // **** End of deferred initialize for Main.motors.control_y.pos_control
            }
            // **** End of deferred initialize for Main.motors.control_y
            // **** Start deferred initialize for Main.motors.control_z
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_z.
                main_motors_control_z_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_z_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_z_self[0]->base.allocations);
                main_motors_control_z_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_z_self[0]->base.allocations);
                main_motors_control_z_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_z_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_z_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_z_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_z
            
            }
            // **** End of deferred initialize for Main.motors.control_z
            // **** Start deferred initialize for Main.motors.control_r
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_r.
                main_motors_control_r_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_r_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_r_self[0]->base.allocations);
                main_motors_control_r_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_r_self[0]->base.allocations);
                main_motors_control_r_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_r_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_r_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_r_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_r
            
            }
            // **** End of deferred initialize for Main.motors.control_r
            // **** Start deferred initialize for Main.motors.control_a1
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_a1.
                main_motors_control_a1_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_a1_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_a1_self[0]->base.allocations);
                main_motors_control_a1_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_a1_self[0]->base.allocations);
                main_motors_control_a1_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_a1_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_a1_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_a1_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_a1
            
            }
            // **** End of deferred initialize for Main.motors.control_a1
            // **** Start deferred initialize for Main.motors.control_a2
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_a2.
                main_motors_control_a2_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_a2_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_a2_self[0]->base.allocations);
                main_motors_control_a2_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_a2_self[0]->base.allocations);
                main_motors_control_a2_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_a2_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_a2_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_a2_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_a2
            
            }
            // **** End of deferred initialize for Main.motors.control_a2
        }
        // **** End of deferred initialize for Main.motors
        // **** Start deferred initialize for Main.home
        {
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of Main.home.
            main_home_self[0]->_lf__reaction_0.num_outputs = 6;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            main_home_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                    6, sizeof(trigger_t**),
                    &main_home_self[0]->base.allocations);
            main_home_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                    6, sizeof(int),
                    &main_home_self[0]->base.allocations);
            main_home_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                    6, sizeof(bool*),
                    &main_home_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    for (int i = 0; i < 6; i++) {
                        main_home_self[0]->_lf__reaction_0.output_produced[i + count]
                                = &main_home_self[0]->_lf_motor_speed[i].is_present;
                    }
                    count += 6;
                }
            }
            
            // ** End initialization for reaction 0 of Main.home
            // Allocate memory to store pointers to the multiport output read 
            // of a contained reactor Main.home.homing_switches
            {
                main_home_self[0]->_lf_homing_switches.read_width = 6;
                main_home_self[0]->_lf_homing_switches.read
                        = (_switches_read_t**)lf_allocate(
                                6, sizeof(_switches_read_t*),
                                &main_home_self[0]->base.allocations); 
            }
        
            // **** Start deferred initialize for Main.home.homing_switches
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.home.homing_switches.
                main_home_homing_switches_self[0]->_lf__reaction_0.num_outputs = 0;
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                }
                
                // ** End initialization for reaction 0 of Main.home.homing_switches
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_2 of Main.home.homing_switches.
                main_home_homing_switches_self[0]->_lf__reaction_1.num_outputs = 6;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_home_homing_switches_self[0]->_lf__reaction_1.triggers = (trigger_t***)lf_allocate(
                        6, sizeof(trigger_t**),
                        &main_home_homing_switches_self[0]->base.allocations);
                main_home_homing_switches_self[0]->_lf__reaction_1.triggered_sizes = (int*)lf_allocate(
                        6, sizeof(int),
                        &main_home_homing_switches_self[0]->base.allocations);
                main_home_homing_switches_self[0]->_lf__reaction_1.output_produced = (bool**)lf_allocate(
                        6, sizeof(bool*),
                        &main_home_homing_switches_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        for (int i = 0; i < 6; i++) {
                            main_home_homing_switches_self[0]->_lf__reaction_1.output_produced[i + count]
                                    = &main_home_homing_switches_self[0]->_lf_read[i].is_present;
                        }
                        count += 6;
                    }
                }
                
                // ** End initialization for reaction 1 of Main.home.homing_switches
            
            }
            // **** End of deferred initialize for Main.home.homing_switches
        }
        // **** End of deferred initialize for Main.home
    }
    // **** End of deferred initialize for Main
    // **** Start non-nested deferred initialize for Main
    {
        // Set number of destination reactors for port motors.target_pos.
        // Iterate over range Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 3;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 1; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 3;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(2,1)->[Main.motors.control_z.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 2; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(3,1)->[Main.motors.control_r.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 3; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(4,1)->[Main.motors.control_a1.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 4; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(5,1)->[Main.motors.control_a2.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 5; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Set number of destination reactors for port qdec.reset_qdec.
        // Iterate over range Main.qdec.reset_qdec(0,1)->[Main.qdec.reset_qdec(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_qdec.reset_qdec._base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_qdec.reset_qdec._base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Set number of destination reactors for port motors.target_sel.
        // Iterate over range Main.motors.target_sel(0,6)->[Main.motors.target_sel(0,6)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 6, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 6; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_main_self[src_runtime]->_lf_motors.target_sel[src_channel]->_base.num_destinations = 1;
                main_main_self[src_runtime]->_lf_motors.target_sel[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
                mixed_radix_incr(&range_mr);
            }
        }
        // Set number of destination reactors for port motors.target_speed.
        // Iterate over range Main.motors.target_speed(0,6)->[Main.motors.target_speed(0,6)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 6, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 6; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_main_self[src_runtime]->_lf_motors.target_speed[src_channel]->_base.num_destinations = 1;
                main_main_self[src_runtime]->_lf_motors.target_speed[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
                mixed_radix_incr(&range_mr);
            }
        }
        {
            int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
            // Iterate over range Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 1 of Main triggers 3 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 3;
                // For reaction 1 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        3, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 1; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 1 of Main triggers 3 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 3;
                // For reaction 1 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        3, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(2,1)->[Main.motors.control_z.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 2; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 1 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 1 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(3,1)->[Main.motors.control_r.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 3; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 1 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 1 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(4,1)->[Main.motors.control_a1.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 4; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 1 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 1 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(5,1)->[Main.motors.control_a2.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 5; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 1 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 1 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 0;
            // Iterate over ranges Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)] and Main.motors.control_x.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 0; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_x.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_x.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_x_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)] and Main.motors.control_x.pos_control.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 0; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_x.pos_control.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_x.pos_control.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][1] = &main_motors_control_x_pos_control_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)] and Main.motors.control_x.force_control.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 0; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_x.force_control.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_x.force_control.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][2] = &main_motors_control_x_force_control_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)] and Main.motors.control_y.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 1; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_y.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_y.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_y_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)] and Main.motors.control_y.pos_control.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 1; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_y.pos_control.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_y.pos_control.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][1] = &main_motors_control_y_pos_control_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)] and Main.motors.control_y.force_control.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 1; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_y.force_control.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_y.force_control.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][2] = &main_motors_control_y_force_control_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(2,1)->[Main.motors.control_z.target_pos(0,1)] and Main.motors.control_z.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 2; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_z.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_z.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_z_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(3,1)->[Main.motors.control_r.target_pos(0,1)] and Main.motors.control_r.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 3; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_r.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_r.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_r_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(4,1)->[Main.motors.control_a1.target_pos(0,1)] and Main.motors.control_a1.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 4; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_a1.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_a1.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_a1_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(5,1)->[Main.motors.control_a2.target_pos(0,1)] and Main.motors.control_a2.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 5; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_a2.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_a2.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_a2_self[dst_runtime]->_lf__target_pos;
                }
            }
        }
        {
            int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
            // Iterate over range Main.qdec.reset_qdec(0,1)->[Main.qdec.reset_qdec(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 2 of Main triggers 1 downstream reactions
                // through port Main.qdec.reset_qdec.
                main_main_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 2 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.qdec.reset_qdec
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 0;
            // Iterate over ranges Main.qdec.reset_qdec(0,1)->[Main.qdec.reset_qdec(0,1)] and Main.qdec.reset_qdec(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 0; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.qdec.reset_qdec(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.qdec.reset_qdec's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_qdec_self[dst_runtime]->_lf__reset_qdec;
                }
            }
        }
        {
            int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
            // Iterate over range Main.motors.target_sel(0,6)->[Main.motors.target_sel(0,6)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 6, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 6; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Reaction 4 of Main triggers 1 downstream reactions
                    // through port Main.motors.target_sel.
                    main_main_self[src_runtime]->_lf__reaction_4.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 4 of Main, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.target_sel
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_main_self[src_runtime]->base.allocations); 
                    main_main_self[src_runtime]->_lf__reaction_4.triggers[triggers_index[src_runtime]++] = trigger_array;
                    mixed_radix_incr(&range_mr);
                }
            }
            // Iterate over range Main.motors.target_speed(0,6)->[Main.motors.target_speed(0,6)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 6, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 6; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Reaction 4 of Main triggers 1 downstream reactions
                    // through port Main.motors.target_speed.
                    main_main_self[src_runtime]->_lf__reaction_4.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 4 of Main, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.target_speed
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_main_self[src_runtime]->base.allocations); 
                    main_main_self[src_runtime]->_lf__reaction_4.triggers[triggers_index[src_runtime]++] = trigger_array;
                    mixed_radix_incr(&range_mr);
                }
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 0;
            // Iterate over ranges Main.motors.target_sel(0,6)->[Main.motors.target_sel(0,6)] and Main.motors.target_sel(0,6).
            {
                int src_start[] =  { 0, 0 };
                int src_value[] =  { 0, 0 }; // Will be incremented.
                int src_radixes[] = { 6, 1 };
                int src_permutation[] = { 0, 1 };
                mixed_radix_int_t src_range_mr = {
                    2,
                    src_value,
                    src_radixes,
                    src_permutation
                };
                // Iterate over range Main.motors.target_sel(0,6).
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 6, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 6; range_count++) {
                        int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(dst_runtime);
                        int dst_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(dst_channel);
                        int dst_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(dst_bank);
                        int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = src_range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = src_range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Point to destination port Main.motors.target_sel's trigger struct.
                        main_main_self[src_runtime]->_lf__reaction_4.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf__target_sel;
                        mixed_radix_incr(&src_range_mr);
                        if (mixed_radix_to_int(&src_range_mr) >= 0 + 6) {
                            // Start over with the source.
                            for (int i = 0; i < src_range_mr.size; i++) {
                                src_range_mr.digits[i] = src_start[i];
                            }
                        }
                        mixed_radix_incr(&range_mr);
                    }
                }
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 6;
            // Iterate over ranges Main.motors.target_speed(0,6)->[Main.motors.target_speed(0,6)] and Main.motors.target_speed(0,6).
            {
                int src_start[] =  { 0, 0 };
                int src_value[] =  { 0, 0 }; // Will be incremented.
                int src_radixes[] = { 6, 1 };
                int src_permutation[] = { 0, 1 };
                mixed_radix_int_t src_range_mr = {
                    2,
                    src_value,
                    src_radixes,
                    src_permutation
                };
                // Iterate over range Main.motors.target_speed(0,6).
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 6, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 6; range_count++) {
                        int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(dst_runtime);
                        int dst_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(dst_channel);
                        int dst_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(dst_bank);
                        int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = src_range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = src_range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Point to destination port Main.motors.target_speed's trigger struct.
                        main_main_self[src_runtime]->_lf__reaction_4.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf__target_speed;
                        mixed_radix_incr(&src_range_mr);
                        if (mixed_radix_to_int(&src_range_mr) >= 0 + 6) {
                            // Start over with the source.
                            for (int i = 0; i < src_range_mr.size; i++) {
                                src_range_mr.digits[i] = src_start[i];
                            }
                        }
                        mixed_radix_incr(&range_mr);
                    }
                }
            }
        }
        {
            int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
            // Iterate over range Main.motors.target_sel(0,6)->[Main.motors.target_sel(0,6)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 6, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 6; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Reaction 5 of Main triggers 1 downstream reactions
                    // through port Main.motors.target_sel.
                    main_main_self[src_runtime]->_lf__reaction_5.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 5 of Main, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.target_sel
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_main_self[src_runtime]->base.allocations); 
                    main_main_self[src_runtime]->_lf__reaction_5.triggers[triggers_index[src_runtime]++] = trigger_array;
                    mixed_radix_incr(&range_mr);
                }
            }
            // Iterate over range Main.motors.target_speed(0,6)->[Main.motors.target_speed(0,6)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 6, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 6; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Reaction 5 of Main triggers 1 downstream reactions
                    // through port Main.motors.target_speed.
                    main_main_self[src_runtime]->_lf__reaction_5.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 5 of Main, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.target_speed
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_main_self[src_runtime]->base.allocations); 
                    main_main_self[src_runtime]->_lf__reaction_5.triggers[triggers_index[src_runtime]++] = trigger_array;
                    mixed_radix_incr(&range_mr);
                }
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 0;
            // Iterate over ranges Main.motors.target_sel(0,6)->[Main.motors.target_sel(0,6)] and Main.motors.target_sel(0,6).
            {
                int src_start[] =  { 0, 0 };
                int src_value[] =  { 0, 0 }; // Will be incremented.
                int src_radixes[] = { 6, 1 };
                int src_permutation[] = { 0, 1 };
                mixed_radix_int_t src_range_mr = {
                    2,
                    src_value,
                    src_radixes,
                    src_permutation
                };
                // Iterate over range Main.motors.target_sel(0,6).
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 6, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 6; range_count++) {
                        int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(dst_runtime);
                        int dst_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(dst_channel);
                        int dst_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(dst_bank);
                        int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = src_range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = src_range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Point to destination port Main.motors.target_sel's trigger struct.
                        main_main_self[src_runtime]->_lf__reaction_5.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf__target_sel;
                        mixed_radix_incr(&src_range_mr);
                        if (mixed_radix_to_int(&src_range_mr) >= 0 + 6) {
                            // Start over with the source.
                            for (int i = 0; i < src_range_mr.size; i++) {
                                src_range_mr.digits[i] = src_start[i];
                            }
                        }
                        mixed_radix_incr(&range_mr);
                    }
                }
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 6;
            // Iterate over ranges Main.motors.target_speed(0,6)->[Main.motors.target_speed(0,6)] and Main.motors.target_speed(0,6).
            {
                int src_start[] =  { 0, 0 };
                int src_value[] =  { 0, 0 }; // Will be incremented.
                int src_radixes[] = { 6, 1 };
                int src_permutation[] = { 0, 1 };
                mixed_radix_int_t src_range_mr = {
                    2,
                    src_value,
                    src_radixes,
                    src_permutation
                };
                // Iterate over range Main.motors.target_speed(0,6).
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 6, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 6; range_count++) {
                        int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(dst_runtime);
                        int dst_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(dst_channel);
                        int dst_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(dst_bank);
                        int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = src_range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = src_range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Point to destination port Main.motors.target_speed's trigger struct.
                        main_main_self[src_runtime]->_lf__reaction_5.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf__target_speed;
                        mixed_radix_incr(&src_range_mr);
                        if (mixed_radix_to_int(&src_range_mr) >= 0 + 6) {
                            // Start over with the source.
                            for (int i = 0; i < src_range_mr.size; i++) {
                                src_range_mr.digits[i] = src_start[i];
                            }
                        }
                        mixed_radix_incr(&range_mr);
                    }
                }
            }
        }
    
        // **** Start non-nested deferred initialize for Main.qdec
        {
        
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 4;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 1; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 3;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(2,1)->[Main.motors.control_z.current_pos(0,1), Main.home.current_pos(2,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 2; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 2;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(3,1)->[Main.motors.control_r.current_pos(0,1), Main.home.current_pos(3,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 3; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 2;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(4,1)->[Main.motors.control_a1.current_pos(0,1), Main.home.current_pos(4,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 4; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 2;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(5,1)->[Main.motors.control_a2.current_pos(0,1), Main.home.current_pos(5,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 5; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 2;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.sea_out.
            // Iterate over range Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_sea_out[src_channel]._base.num_destinations = 3;
                main_qdec_self[src_runtime]->_lf_sea_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.sea_out.
            // Iterate over range Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 1; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_sea_out[src_channel]._base.num_destinations = 3;
                main_qdec_self[src_runtime]->_lf_sea_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.sea_out.
            // Iterate over range Main.qdec.sea_out(2,4)->[Main.home.sea_pos(2,4)].
            {
                int range_start[] =  { 2, 0 };
                int range_radixes[] = { 6, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 2; range_count < 2 + 4; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    main_qdec_self[src_runtime]->_lf_sea_out[src_channel]._base.num_destinations = 1;
                    main_qdec_self[src_runtime]->_lf_sea_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
                    mixed_radix_incr(&range_mr);
                }
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 4 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 4;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            4, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 1; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 3 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 3;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            3, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(2,1)->[Main.motors.control_z.current_pos(0,1), Main.home.current_pos(2,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 2; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 2 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 2;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            2, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(3,1)->[Main.motors.control_r.current_pos(0,1), Main.home.current_pos(3,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 3; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 2 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 2;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            2, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(4,1)->[Main.motors.control_a1.current_pos(0,1), Main.home.current_pos(4,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 4; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 2 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 2;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            2, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(5,1)->[Main.motors.control_a2.current_pos(0,1), Main.home.current_pos(5,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 5; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 2 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 2;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            2, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 3 downstream reactions
                    // through port Main.qdec.sea_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 3;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.sea_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            3, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 1; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 3 downstream reactions
                    // through port Main.qdec.sea_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 3;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.sea_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            3, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.sea_out(2,4)->[Main.home.sea_pos(2,4)].
                {
                    int range_start[] =  { 2, 0 };
                    int range_radixes[] = { 6, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 2; range_count < 2 + 4; range_count++) {
                        int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Reaction 2 of Main.qdec triggers 1 downstream reactions
                        // through port Main.qdec.sea_out.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 2 of Main.qdec, allocate an
                        // array of trigger pointers for downstream reactions through port Main.qdec.sea_out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_qdec_self[src_runtime]->base.allocations); 
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                        mixed_radix_incr(&range_mr);
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] and Main.motors.control_x.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_x.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_x.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_x_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] and Main.motors.control_x.pos_control.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_x.pos_control.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_x.pos_control.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_motors_control_x_pos_control_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] and Main.motors.control_x.force_control.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_x.force_control.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_x.force_control.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_motors_control_x_force_control_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] and Main.home.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][3] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)] and Main.motors.control_y.force_control.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 1; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_y.force_control.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_y.force_control.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_y_force_control_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)] and Main.motors.control_y.pos_control.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 1; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_y.pos_control.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_y.pos_control.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_motors_control_y_pos_control_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)] and Main.home.current_pos(1,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 1; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(1,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 1; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(2,1)->[Main.motors.control_z.current_pos(0,1), Main.home.current_pos(2,1)] and Main.motors.control_z.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 2; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_z.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_z.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_z_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(2,1)->[Main.motors.control_z.current_pos(0,1), Main.home.current_pos(2,1)] and Main.home.current_pos(2,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 2; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(2,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 2; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(3,1)->[Main.motors.control_r.current_pos(0,1), Main.home.current_pos(3,1)] and Main.motors.control_r.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 3; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_r.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_r.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_r_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(3,1)->[Main.motors.control_r.current_pos(0,1), Main.home.current_pos(3,1)] and Main.home.current_pos(3,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 3; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(3,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 3; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(4,1)->[Main.motors.control_a1.current_pos(0,1), Main.home.current_pos(4,1)] and Main.motors.control_a1.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 4; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_a1.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_a1.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_a1_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(4,1)->[Main.motors.control_a1.current_pos(0,1), Main.home.current_pos(4,1)] and Main.home.current_pos(4,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 4; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(4,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 4; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(5,1)->[Main.motors.control_a2.current_pos(0,1), Main.home.current_pos(5,1)] and Main.motors.control_a2.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 5; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_a2.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_a2.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_a2_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(5,1)->[Main.motors.control_a2.current_pos(0,1), Main.home.current_pos(5,1)] and Main.home.current_pos(5,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 5; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(5,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 5; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 6;
                // Iterate over ranges Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)] and Main.motors.control_x.sea_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_x.sea_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_x.sea_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_x_self[dst_runtime]->_lf__sea_pos;
                    }
                }
                // Iterate over ranges Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)] and Main.motors.control_x.force_control.sea_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_x.force_control.sea_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_x.force_control.sea_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_motors_control_x_force_control_self[dst_runtime]->_lf__sea_pos;
                    }
                }
                // Iterate over ranges Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)] and Main.home.sea_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.sea_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.sea_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_home_self[dst_runtime]->_lf__sea_pos;
                    }
                }
                // Iterate over ranges Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)] and Main.motors.control_y.sea_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 1; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_y.sea_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_y.sea_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_y_self[dst_runtime]->_lf__sea_pos;
                    }
                }
                // Iterate over ranges Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)] and Main.motors.control_y.force_control.sea_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 1; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_y.force_control.sea_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_y.force_control.sea_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_motors_control_y_force_control_self[dst_runtime]->_lf__sea_pos;
                    }
                }
                // Iterate over ranges Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)] and Main.home.sea_pos(1,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 1; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.sea_pos(1,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 1; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.sea_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_home_self[dst_runtime]->_lf__sea_pos;
                    }
                }
                // Iterate over ranges Main.qdec.sea_out(2,4)->[Main.home.sea_pos(2,4)] and Main.home.sea_pos(2,4).
                {
                    int src_start[] =  { 2, 0 };
                    int src_value[] =  { 2, 0 }; // Will be incremented.
                    int src_radixes[] = { 6, 1 };
                    int src_permutation[] = { 0, 1 };
                    mixed_radix_int_t src_range_mr = {
                        2,
                        src_value,
                        src_radixes,
                        src_permutation
                    };
                    // Iterate over range Main.home.sea_pos(2,4).
                    {
                        int range_start[] =  { 2, 0 };
                        int range_radixes[] = { 6, 1 };
                        int permutation[] = { 0, 1 };
                        mixed_radix_int_t range_mr = {
                            2,
                            range_start,
                            range_radixes,
                            permutation
                        };
                        for (int range_count = 2; range_count < 2 + 4; range_count++) {
                            int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                            SUPPRESS_UNUSED_WARNING(dst_runtime);
                            int dst_channel = range_mr.digits[0]; // Channel index.
                            SUPPRESS_UNUSED_WARNING(dst_channel);
                            int dst_bank = range_mr.digits[1]; // Bank index.
                            SUPPRESS_UNUSED_WARNING(dst_bank);
                            int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                            SUPPRESS_UNUSED_WARNING(src_runtime);
                            int src_channel = src_range_mr.digits[0]; // Channel index.
                            SUPPRESS_UNUSED_WARNING(src_channel);
                            int src_bank = src_range_mr.digits[1]; // Bank index.
                            SUPPRESS_UNUSED_WARNING(src_bank);
                            // Point to destination port Main.home.sea_pos's trigger struct.
                            main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_home_self[dst_runtime]->_lf__sea_pos;
                            mixed_radix_incr(&src_range_mr);
                            if (mixed_radix_to_int(&src_range_mr) >= 2 + 4) {
                                // Start over with the source.
                                for (int i = 0; i < src_range_mr.size; i++) {
                                    src_range_mr.digits[i] = src_start[i];
                                }
                            }
                            mixed_radix_incr(&range_mr);
                        }
                    }
                }
            }
        
        }
        // **** End of non-nested deferred initialize for Main.qdec
        // **** Start non-nested deferred initialize for Main.motors
        {
            // Set number of destination reactors for port stepper.set_speed_0.
            // Iterate over range Main.motors.stepper.set_speed_0(0,1)->[Main.motors.stepper.set_speed_0(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_stepper.set_speed_0._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_stepper.set_speed_0._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
            // Set number of destination reactors for port stepper.set_speed_1.
            // Iterate over range Main.motors.stepper.set_speed_1(0,1)->[Main.motors.stepper.set_speed_1(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_stepper.set_speed_1._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_stepper.set_speed_1._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
            // Set number of destination reactors for port usm.set_speed_2.
            // Iterate over range Main.motors.usm.set_speed_2(0,1)->[Main.motors.usm.set_speed_2(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_usm.set_speed_2._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_usm.set_speed_2._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
            // Set number of destination reactors for port usm.set_speed_3.
            // Iterate over range Main.motors.usm.set_speed_3(0,1)->[Main.motors.usm.set_speed_3(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_usm.set_speed_3._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_usm.set_speed_3._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
            // Set number of destination reactors for port usm.set_speed_4.
            // Iterate over range Main.motors.usm.set_speed_4(0,1)->[Main.motors.usm.set_speed_4(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_usm.set_speed_4._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_usm.set_speed_4._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
        
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range Main.motors.stepper.set_speed_0(0,1)->[Main.motors.stepper.set_speed_0(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.stepper.set_speed_0.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.stepper.set_speed_0
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.motors.stepper.set_speed_1(0,1)->[Main.motors.stepper.set_speed_1(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.stepper.set_speed_1.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.stepper.set_speed_1
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.motors.usm.set_speed_2(0,1)->[Main.motors.usm.set_speed_2(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.usm.set_speed_2.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.usm.set_speed_2
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.motors.usm.set_speed_3(0,1)->[Main.motors.usm.set_speed_3(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.usm.set_speed_3.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.usm.set_speed_3
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.motors.usm.set_speed_4(0,1)->[Main.motors.usm.set_speed_4(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.usm.set_speed_4.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.usm.set_speed_4
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges Main.motors.stepper.set_speed_0(0,1)->[Main.motors.stepper.set_speed_0(0,1)] and Main.motors.stepper.set_speed_0(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.stepper.set_speed_0(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.stepper.set_speed_0's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_stepper_self[dst_runtime]->_lf__set_speed_0;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 1;
                // Iterate over ranges Main.motors.stepper.set_speed_1(0,1)->[Main.motors.stepper.set_speed_1(0,1)] and Main.motors.stepper.set_speed_1(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.stepper.set_speed_1(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.stepper.set_speed_1's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_stepper_self[dst_runtime]->_lf__set_speed_1;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 2;
                // Iterate over ranges Main.motors.usm.set_speed_2(0,1)->[Main.motors.usm.set_speed_2(0,1)] and Main.motors.usm.set_speed_2(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.usm.set_speed_2(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.usm.set_speed_2's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_usm_self[dst_runtime]->_lf__set_speed_2;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 3;
                // Iterate over ranges Main.motors.usm.set_speed_3(0,1)->[Main.motors.usm.set_speed_3(0,1)] and Main.motors.usm.set_speed_3(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.usm.set_speed_3(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.usm.set_speed_3's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_usm_self[dst_runtime]->_lf__set_speed_3;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 4;
                // Iterate over ranges Main.motors.usm.set_speed_4(0,1)->[Main.motors.usm.set_speed_4(0,1)] and Main.motors.usm.set_speed_4(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.usm.set_speed_4(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.usm.set_speed_4's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_usm_self[dst_runtime]->_lf__set_speed_4;
                    }
                }
            }
        
            // **** Start non-nested deferred initialize for Main.motors.stepper
            {
            
            
            
            
            }
            // **** End of non-nested deferred initialize for Main.motors.stepper
            // **** Start non-nested deferred initialize for Main.motors.usm
            {
            
            
            
            
            }
            // **** End of non-nested deferred initialize for Main.motors.usm
            // **** Start non-nested deferred initialize for Main.motors.control_x
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_x.out.
                // Iterate over range Main.motors.control_x.out(0,1)->[Main.motors.control_x.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_x_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_x_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_x_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_x.out(0,1)->[Main.motors.control_x.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 1 of Main.motors.control_x triggers 1 downstream reactions
                        // through port Main.motors.control_x.out.
                        main_motors_control_x_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 1 of Main.motors.control_x, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_x.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_x_self[src_runtime]->base.allocations); 
                        main_motors_control_x_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_x.out(0,1)->[Main.motors.control_x.out(0,1)] and Main.motors.control_x.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_x.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_x.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_x_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_x.out_trigger;
                        }
                    }
                }
            
                // **** Start non-nested deferred initialize for Main.motors.control_x.force_control
                {
                
                    // For reference counting, set num_destinations for port Main.motors.control_x.force_control.out.
                    // Iterate over range Main.motors.control_x.force_control.out(0,1)->[Main.motors.control_x.force_control.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        main_motors_control_x_force_control_self[src_runtime]->_lf_out._base.num_destinations = 1;
                        main_motors_control_x_force_control_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_x_force_control_self[src_runtime];
                    }
                    {
                        int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                        // Iterate over range Main.motors.control_x.force_control.out(0,1)->[Main.motors.control_x.force_control.out(0,1)].
                        {
                            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                            int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Reaction 0 of Main.motors.control_x.force_control triggers 1 downstream reactions
                            // through port Main.motors.control_x.force_control.out.
                            main_motors_control_x_force_control_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                            // For reaction 0 of Main.motors.control_x.force_control, allocate an
                            // array of trigger pointers for downstream reactions through port Main.motors.control_x.force_control.out
                            trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                    1, sizeof(trigger_t*),
                                    &main_motors_control_x_force_control_self[src_runtime]->base.allocations); 
                            main_motors_control_x_force_control_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                        }
                        for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                        // Iterate over ranges Main.motors.control_x.force_control.out(0,1)->[Main.motors.control_x.force_control.out(0,1)] and Main.motors.control_x.force_control.out(0,1).
                        {
                            int src_runtime = 0; // Runtime index.
                            SUPPRESS_UNUSED_WARNING(src_runtime);
                            int src_channel = 0; // Channel index.
                            SUPPRESS_UNUSED_WARNING(src_channel);
                            int src_bank = 0; // Bank index.
                            SUPPRESS_UNUSED_WARNING(src_bank);
                            // Iterate over range Main.motors.control_x.force_control.out(0,1).
                            {
                                int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                                int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                                int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                                // Port Main.motors.control_x.force_control.out has reactions in its parent's parent.
                                // Point to the trigger struct for those reactions.
                                main_motors_control_x_force_control_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_x_self[dst_runtime]->_lf_force_control.out_trigger;
                            }
                        }
                    }
                
                }
                // **** End of non-nested deferred initialize for Main.motors.control_x.force_control
                // **** Start non-nested deferred initialize for Main.motors.control_x.pos_control
                {
                
                    // For reference counting, set num_destinations for port Main.motors.control_x.pos_control.out.
                    // Iterate over range Main.motors.control_x.pos_control.out(0,1)->[Main.motors.control_x.pos_control.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        main_motors_control_x_pos_control_self[src_runtime]->_lf_out._base.num_destinations = 1;
                        main_motors_control_x_pos_control_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_x_pos_control_self[src_runtime];
                    }
                    {
                        int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                        // Iterate over range Main.motors.control_x.pos_control.out(0,1)->[Main.motors.control_x.pos_control.out(0,1)].
                        {
                            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                            int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Reaction 0 of Main.motors.control_x.pos_control triggers 1 downstream reactions
                            // through port Main.motors.control_x.pos_control.out.
                            main_motors_control_x_pos_control_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                            // For reaction 0 of Main.motors.control_x.pos_control, allocate an
                            // array of trigger pointers for downstream reactions through port Main.motors.control_x.pos_control.out
                            trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                    1, sizeof(trigger_t*),
                                    &main_motors_control_x_pos_control_self[src_runtime]->base.allocations); 
                            main_motors_control_x_pos_control_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                        }
                        for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                        // Iterate over ranges Main.motors.control_x.pos_control.out(0,1)->[Main.motors.control_x.pos_control.out(0,1)] and Main.motors.control_x.pos_control.out(0,1).
                        {
                            int src_runtime = 0; // Runtime index.
                            SUPPRESS_UNUSED_WARNING(src_runtime);
                            int src_channel = 0; // Channel index.
                            SUPPRESS_UNUSED_WARNING(src_channel);
                            int src_bank = 0; // Bank index.
                            SUPPRESS_UNUSED_WARNING(src_bank);
                            // Iterate over range Main.motors.control_x.pos_control.out(0,1).
                            {
                                int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                                int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                                int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                                // Port Main.motors.control_x.pos_control.out has reactions in its parent's parent.
                                // Point to the trigger struct for those reactions.
                                main_motors_control_x_pos_control_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_x_self[dst_runtime]->_lf_pos_control.out_trigger;
                            }
                        }
                    }
                
                }
                // **** End of non-nested deferred initialize for Main.motors.control_x.pos_control
            }
            // **** End of non-nested deferred initialize for Main.motors.control_x
            // **** Start non-nested deferred initialize for Main.motors.control_y
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_y.out.
                // Iterate over range Main.motors.control_y.out(0,1)->[Main.motors.control_y.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_y_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_y_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_y_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_y.out(0,1)->[Main.motors.control_y.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 1 of Main.motors.control_y triggers 1 downstream reactions
                        // through port Main.motors.control_y.out.
                        main_motors_control_y_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 1 of Main.motors.control_y, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_y.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_y_self[src_runtime]->base.allocations); 
                        main_motors_control_y_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_y.out(0,1)->[Main.motors.control_y.out(0,1)] and Main.motors.control_y.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_y.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_y.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_y_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_y.out_trigger;
                        }
                    }
                }
            
                // **** Start non-nested deferred initialize for Main.motors.control_y.force_control
                {
                
                    // For reference counting, set num_destinations for port Main.motors.control_y.force_control.out.
                    // Iterate over range Main.motors.control_y.force_control.out(0,1)->[Main.motors.control_y.force_control.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        main_motors_control_y_force_control_self[src_runtime]->_lf_out._base.num_destinations = 1;
                        main_motors_control_y_force_control_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_y_force_control_self[src_runtime];
                    }
                    {
                        int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                        // Iterate over range Main.motors.control_y.force_control.out(0,1)->[Main.motors.control_y.force_control.out(0,1)].
                        {
                            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                            int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Reaction 0 of Main.motors.control_y.force_control triggers 1 downstream reactions
                            // through port Main.motors.control_y.force_control.out.
                            main_motors_control_y_force_control_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                            // For reaction 0 of Main.motors.control_y.force_control, allocate an
                            // array of trigger pointers for downstream reactions through port Main.motors.control_y.force_control.out
                            trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                    1, sizeof(trigger_t*),
                                    &main_motors_control_y_force_control_self[src_runtime]->base.allocations); 
                            main_motors_control_y_force_control_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                        }
                        for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                        // Iterate over ranges Main.motors.control_y.force_control.out(0,1)->[Main.motors.control_y.force_control.out(0,1)] and Main.motors.control_y.force_control.out(0,1).
                        {
                            int src_runtime = 0; // Runtime index.
                            SUPPRESS_UNUSED_WARNING(src_runtime);
                            int src_channel = 0; // Channel index.
                            SUPPRESS_UNUSED_WARNING(src_channel);
                            int src_bank = 0; // Bank index.
                            SUPPRESS_UNUSED_WARNING(src_bank);
                            // Iterate over range Main.motors.control_y.force_control.out(0,1).
                            {
                                int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                                int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                                int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                                // Port Main.motors.control_y.force_control.out has reactions in its parent's parent.
                                // Point to the trigger struct for those reactions.
                                main_motors_control_y_force_control_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_y_self[dst_runtime]->_lf_force_control.out_trigger;
                            }
                        }
                    }
                
                }
                // **** End of non-nested deferred initialize for Main.motors.control_y.force_control
                // **** Start non-nested deferred initialize for Main.motors.control_y.pos_control
                {
                
                    // For reference counting, set num_destinations for port Main.motors.control_y.pos_control.out.
                    // Iterate over range Main.motors.control_y.pos_control.out(0,1)->[Main.motors.control_y.pos_control.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        main_motors_control_y_pos_control_self[src_runtime]->_lf_out._base.num_destinations = 1;
                        main_motors_control_y_pos_control_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_y_pos_control_self[src_runtime];
                    }
                    {
                        int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                        // Iterate over range Main.motors.control_y.pos_control.out(0,1)->[Main.motors.control_y.pos_control.out(0,1)].
                        {
                            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                            int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Reaction 0 of Main.motors.control_y.pos_control triggers 1 downstream reactions
                            // through port Main.motors.control_y.pos_control.out.
                            main_motors_control_y_pos_control_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                            // For reaction 0 of Main.motors.control_y.pos_control, allocate an
                            // array of trigger pointers for downstream reactions through port Main.motors.control_y.pos_control.out
                            trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                    1, sizeof(trigger_t*),
                                    &main_motors_control_y_pos_control_self[src_runtime]->base.allocations); 
                            main_motors_control_y_pos_control_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                        }
                        for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                        // Iterate over ranges Main.motors.control_y.pos_control.out(0,1)->[Main.motors.control_y.pos_control.out(0,1)] and Main.motors.control_y.pos_control.out(0,1).
                        {
                            int src_runtime = 0; // Runtime index.
                            SUPPRESS_UNUSED_WARNING(src_runtime);
                            int src_channel = 0; // Channel index.
                            SUPPRESS_UNUSED_WARNING(src_channel);
                            int src_bank = 0; // Bank index.
                            SUPPRESS_UNUSED_WARNING(src_bank);
                            // Iterate over range Main.motors.control_y.pos_control.out(0,1).
                            {
                                int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                                int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                                int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                                // Port Main.motors.control_y.pos_control.out has reactions in its parent's parent.
                                // Point to the trigger struct for those reactions.
                                main_motors_control_y_pos_control_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_y_self[dst_runtime]->_lf_pos_control.out_trigger;
                            }
                        }
                    }
                
                }
                // **** End of non-nested deferred initialize for Main.motors.control_y.pos_control
            }
            // **** End of non-nested deferred initialize for Main.motors.control_y
            // **** Start non-nested deferred initialize for Main.motors.control_z
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_z.out.
                // Iterate over range Main.motors.control_z.out(0,1)->[Main.motors.control_z.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_z_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_z_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_z_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_z.out(0,1)->[Main.motors.control_z.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_z triggers 1 downstream reactions
                        // through port Main.motors.control_z.out.
                        main_motors_control_z_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_z, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_z.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_z_self[src_runtime]->base.allocations); 
                        main_motors_control_z_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_z.out(0,1)->[Main.motors.control_z.out(0,1)] and Main.motors.control_z.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_z.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_z.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_z_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_z.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_z
            // **** Start non-nested deferred initialize for Main.motors.control_r
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_r.out.
                // Iterate over range Main.motors.control_r.out(0,1)->[Main.motors.control_r.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_r_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_r_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_r_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_r.out(0,1)->[Main.motors.control_r.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_r triggers 1 downstream reactions
                        // through port Main.motors.control_r.out.
                        main_motors_control_r_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_r, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_r.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_r_self[src_runtime]->base.allocations); 
                        main_motors_control_r_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_r.out(0,1)->[Main.motors.control_r.out(0,1)] and Main.motors.control_r.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_r.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_r.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_r_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_r.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_r
            // **** Start non-nested deferred initialize for Main.motors.control_a1
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_a1.out.
                // Iterate over range Main.motors.control_a1.out(0,1)->[Main.motors.control_a1.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_a1_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_a1_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_a1_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_a1.out(0,1)->[Main.motors.control_a1.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_a1 triggers 1 downstream reactions
                        // through port Main.motors.control_a1.out.
                        main_motors_control_a1_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_a1, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_a1.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_a1_self[src_runtime]->base.allocations); 
                        main_motors_control_a1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_a1.out(0,1)->[Main.motors.control_a1.out(0,1)] and Main.motors.control_a1.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_a1.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_a1.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_a1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_a1.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_a1
            // **** Start non-nested deferred initialize for Main.motors.control_a2
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_a2.out.
                // Iterate over range Main.motors.control_a2.out(0,1)->[Main.motors.control_a2.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_a2_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_a2_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_a2_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_a2.out(0,1)->[Main.motors.control_a2.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_a2 triggers 1 downstream reactions
                        // through port Main.motors.control_a2.out.
                        main_motors_control_a2_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_a2, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_a2.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_a2_self[src_runtime]->base.allocations); 
                        main_motors_control_a2_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_a2.out(0,1)->[Main.motors.control_a2.out(0,1)] and Main.motors.control_a2.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_a2.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_a2.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_a2_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_a2.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_a2
        }
        // **** End of non-nested deferred initialize for Main.motors
        // **** Start non-nested deferred initialize for Main.home
        {
        
            // For reference counting, set num_destinations for port Main.home.motor_speed.
            // Iterate over range Main.home.motor_speed(0,6)->[Main.home.motor_speed(0,6)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 6, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 6; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    main_home_self[src_runtime]->_lf_motor_speed[src_channel]._base.num_destinations = 1;
                    main_home_self[src_runtime]->_lf_motor_speed[src_channel]._base.source_reactor = (self_base_t*)main_home_self[src_runtime];
                    mixed_radix_incr(&range_mr);
                }
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range Main.home.motor_speed(0,6)->[Main.home.motor_speed(0,6)].
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 6, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 6; range_count++) {
                        int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Reaction 0 of Main.home triggers 1 downstream reactions
                        // through port Main.home.motor_speed.
                        main_home_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.home, allocate an
                        // array of trigger pointers for downstream reactions through port Main.home.motor_speed
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_home_self[src_runtime]->base.allocations); 
                        main_home_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                        mixed_radix_incr(&range_mr);
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges Main.home.motor_speed(0,6)->[Main.home.motor_speed(0,6)] and Main.home.motor_speed(0,6).
                {
                    int src_start[] =  { 0, 0 };
                    int src_value[] =  { 0, 0 }; // Will be incremented.
                    int src_radixes[] = { 6, 1 };
                    int src_permutation[] = { 0, 1 };
                    mixed_radix_int_t src_range_mr = {
                        2,
                        src_value,
                        src_radixes,
                        src_permutation
                    };
                    // Iterate over range Main.home.motor_speed(0,6).
                    {
                        int range_start[] =  { 0, 0 };
                        int range_radixes[] = { 6, 1 };
                        int permutation[] = { 0, 1 };
                        mixed_radix_int_t range_mr = {
                            2,
                            range_start,
                            range_radixes,
                            permutation
                        };
                        for (int range_count = 0; range_count < 0 + 6; range_count++) {
                            int dst_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                            SUPPRESS_UNUSED_WARNING(dst_runtime);
                            int dst_channel = range_mr.digits[0]; // Channel index.
                            SUPPRESS_UNUSED_WARNING(dst_channel);
                            int dst_bank = range_mr.digits[1]; // Bank index.
                            SUPPRESS_UNUSED_WARNING(dst_bank);
                            int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                            SUPPRESS_UNUSED_WARNING(src_runtime);
                            int src_channel = src_range_mr.digits[0]; // Channel index.
                            SUPPRESS_UNUSED_WARNING(src_channel);
                            int src_bank = src_range_mr.digits[1]; // Bank index.
                            SUPPRESS_UNUSED_WARNING(src_bank);
                            // Port Main.home.motor_speed has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_home_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_main_self[dst_runtime]->_lf_home.motor_speed_trigger;
                            mixed_radix_incr(&src_range_mr);
                            if (mixed_radix_to_int(&src_range_mr) >= 0 + 6) {
                                // Start over with the source.
                                for (int i = 0; i < src_range_mr.size; i++) {
                                    src_range_mr.digits[i] = src_start[i];
                                }
                            }
                            mixed_radix_incr(&range_mr);
                        }
                    }
                }
            }
        
            // **** Start non-nested deferred initialize for Main.home.homing_switches
            {
            
                // For reference counting, set num_destinations for port Main.home.homing_switches.read.
                // Iterate over range Main.home.homing_switches.read(0,6)->[Main.home.homing_switches.read(0,6)].
                {
                    int range_start[] =  { 0, 0, 0 };
                    int range_radixes[] = { 6, 1, 1 };
                    int permutation[] = { 0, 1, 2 };
                    mixed_radix_int_t range_mr = {
                        3,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 6; range_count++) {
                        int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        main_home_homing_switches_self[src_runtime]->_lf_read[src_channel]._base.num_destinations = 1;
                        main_home_homing_switches_self[src_runtime]->_lf_read[src_channel]._base.source_reactor = (self_base_t*)main_home_homing_switches_self[src_runtime];
                        mixed_radix_incr(&range_mr);
                    }
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.home.homing_switches.read(0,6)->[Main.home.homing_switches.read(0,6)].
                    {
                        int range_start[] =  { 0, 0, 0 };
                        int range_radixes[] = { 6, 1, 1 };
                        int permutation[] = { 0, 1, 2 };
                        mixed_radix_int_t range_mr = {
                            3,
                            range_start,
                            range_radixes,
                            permutation
                        };
                        for (int range_count = 0; range_count < 0 + 6; range_count++) {
                            int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                            SUPPRESS_UNUSED_WARNING(src_runtime);
                            int src_channel = range_mr.digits[0]; // Channel index.
                            SUPPRESS_UNUSED_WARNING(src_channel);
                            int src_bank = range_mr.digits[1]; // Bank index.
                            SUPPRESS_UNUSED_WARNING(src_bank);
                            // Reaction 1 of Main.home.homing_switches triggers 1 downstream reactions
                            // through port Main.home.homing_switches.read.
                            main_home_homing_switches_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                            // For reaction 1 of Main.home.homing_switches, allocate an
                            // array of trigger pointers for downstream reactions through port Main.home.homing_switches.read
                            trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                    1, sizeof(trigger_t*),
                                    &main_home_homing_switches_self[src_runtime]->base.allocations); 
                            main_home_homing_switches_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                            mixed_radix_incr(&range_mr);
                        }
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.home.homing_switches.read(0,6)->[Main.home.homing_switches.read(0,6)] and Main.home.homing_switches.read(0,6).
                    {
                        int src_start[] =  { 0, 0, 0 };
                        int src_value[] =  { 0, 0, 0 }; // Will be incremented.
                        int src_radixes[] = { 6, 1, 1 };
                        int src_permutation[] = { 0, 1, 2 };
                        mixed_radix_int_t src_range_mr = {
                            3,
                            src_value,
                            src_radixes,
                            src_permutation
                        };
                        // Iterate over range Main.home.homing_switches.read(0,6).
                        {
                            int range_start[] =  { 0, 0, 0 };
                            int range_radixes[] = { 6, 1, 1 };
                            int permutation[] = { 0, 1, 2 };
                            mixed_radix_int_t range_mr = {
                                3,
                                range_start,
                                range_radixes,
                                permutation
                            };
                            for (int range_count = 0; range_count < 0 + 6; range_count++) {
                                int dst_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                                SUPPRESS_UNUSED_WARNING(dst_runtime);
                                int dst_channel = range_mr.digits[0]; // Channel index.
                                SUPPRESS_UNUSED_WARNING(dst_channel);
                                int dst_bank = range_mr.digits[1]; // Bank index.
                                SUPPRESS_UNUSED_WARNING(dst_bank);
                                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                                SUPPRESS_UNUSED_WARNING(src_runtime);
                                int src_channel = src_range_mr.digits[0]; // Channel index.
                                SUPPRESS_UNUSED_WARNING(src_channel);
                                int src_bank = src_range_mr.digits[1]; // Bank index.
                                SUPPRESS_UNUSED_WARNING(src_bank);
                                // Port Main.home.homing_switches.read has reactions in its parent's parent.
                                // Point to the trigger struct for those reactions.
                                main_home_homing_switches_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_home_self[dst_runtime]->_lf_homing_switches.read_trigger;
                                mixed_radix_incr(&src_range_mr);
                                if (mixed_radix_to_int(&src_range_mr) >= 0 + 6) {
                                    // Start over with the source.
                                    for (int i = 0; i < src_range_mr.size; i++) {
                                        src_range_mr.digits[i] = src_start[i];
                                    }
                                }
                                mixed_radix_incr(&range_mr);
                            }
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.home.homing_switches
        }
        // **** End of non-nested deferred initialize for Main.home
    }
    // **** End of non-nested deferred initialize for Main
    // Connect inputs and outputs for reactor Main.
    // Connect inputs and outputs for reactor Main.qdec.
    // Connect Main.qdec.reset_qdec(0,1)->[Main.qdec.reset_qdec(0,1)] to port Main.qdec.reset_qdec(0,1)
    // Iterate over ranges Main.qdec.reset_qdec(0,1)->[Main.qdec.reset_qdec(0,1)] and Main.qdec.reset_qdec(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.qdec.reset_qdec(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_qdec_self[dst_runtime]->_lf_reset_qdec = (_qdec_reset_qdec_t*)&main_main_self[src_runtime]->_lf_qdec.reset_qdec;
        }
    }
    // Connect Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] to port Main.motors.control_x.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] and Main.motors.control_x.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_x_self[dst_runtime]->_lf_current_pos = (_sea_controllerx_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] to port Main.motors.control_x.pos_control.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] and Main.motors.control_x.pos_control.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.pos_control.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_x_pos_control_self[dst_runtime]->_lf_current_pos = (_pid_controller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] to port Main.motors.control_x.force_control.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] and Main.motors.control_x.force_control.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.force_control.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_x_force_control_self[dst_runtime]->_lf_current_pos = (_ffb_controller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] to port Main.home.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_x.current_pos(0,1), Main.motors.control_x.pos_control.current_pos(0,1), Main.motors.control_x.force_control.current_pos(0,1), Main.home.current_pos(0,1)] and Main.home.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)] to port Main.motors.control_y.force_control.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)] and Main.motors.control_y.force_control.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_y.force_control.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_y_force_control_self[dst_runtime]->_lf_current_pos = (_ffb_controller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)] to port Main.motors.control_y.pos_control.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)] and Main.motors.control_y.pos_control.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_y.pos_control.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_y_pos_control_self[dst_runtime]->_lf_current_pos = (_pid_controller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)] to port Main.home.current_pos(1,1)
    // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_y.force_control.current_pos(0,1), Main.motors.control_y.pos_control.current_pos(0,1), Main.home.current_pos(1,1)] and Main.home.current_pos(1,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(1,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 1; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(2,1)->[Main.motors.control_z.current_pos(0,1), Main.home.current_pos(2,1)] to port Main.motors.control_z.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(2,1)->[Main.motors.control_z.current_pos(0,1), Main.home.current_pos(2,1)] and Main.motors.control_z.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 2; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_z.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_z_self[dst_runtime]->_lf_current_pos = (_pid_controller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(2,1)->[Main.motors.control_z.current_pos(0,1), Main.home.current_pos(2,1)] to port Main.home.current_pos(2,1)
    // Iterate over ranges Main.qdec.qdec_out(2,1)->[Main.motors.control_z.current_pos(0,1), Main.home.current_pos(2,1)] and Main.home.current_pos(2,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 2; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(2,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 2; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(3,1)->[Main.motors.control_r.current_pos(0,1), Main.home.current_pos(3,1)] to port Main.motors.control_r.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(3,1)->[Main.motors.control_r.current_pos(0,1), Main.home.current_pos(3,1)] and Main.motors.control_r.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 3; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_r.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_r_self[dst_runtime]->_lf_current_pos = (_pid_controller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(3,1)->[Main.motors.control_r.current_pos(0,1), Main.home.current_pos(3,1)] to port Main.home.current_pos(3,1)
    // Iterate over ranges Main.qdec.qdec_out(3,1)->[Main.motors.control_r.current_pos(0,1), Main.home.current_pos(3,1)] and Main.home.current_pos(3,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 3; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(3,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 3; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(4,1)->[Main.motors.control_a1.current_pos(0,1), Main.home.current_pos(4,1)] to port Main.motors.control_a1.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(4,1)->[Main.motors.control_a1.current_pos(0,1), Main.home.current_pos(4,1)] and Main.motors.control_a1.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 4; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_a1.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_a1_self[dst_runtime]->_lf_current_pos = (_pid_controller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(4,1)->[Main.motors.control_a1.current_pos(0,1), Main.home.current_pos(4,1)] to port Main.home.current_pos(4,1)
    // Iterate over ranges Main.qdec.qdec_out(4,1)->[Main.motors.control_a1.current_pos(0,1), Main.home.current_pos(4,1)] and Main.home.current_pos(4,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 4; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(4,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 4; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(5,1)->[Main.motors.control_a2.current_pos(0,1), Main.home.current_pos(5,1)] to port Main.motors.control_a2.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(5,1)->[Main.motors.control_a2.current_pos(0,1), Main.home.current_pos(5,1)] and Main.motors.control_a2.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 5; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_a2.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_a2_self[dst_runtime]->_lf_current_pos = (_pid_controller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(5,1)->[Main.motors.control_a2.current_pos(0,1), Main.home.current_pos(5,1)] to port Main.home.current_pos(5,1)
    // Iterate over ranges Main.qdec.qdec_out(5,1)->[Main.motors.control_a2.current_pos(0,1), Main.home.current_pos(5,1)] and Main.home.current_pos(5,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 5; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(5,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 5; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)] to port Main.motors.control_x.sea_pos(0,1)
    // Iterate over ranges Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)] and Main.motors.control_x.sea_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.sea_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_x_self[dst_runtime]->_lf_sea_pos = (_sea_controllerx_sea_pos_t*)&main_qdec_self[src_runtime]->_lf_sea_out[src_channel];
        }
    }
    // Connect Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)] to port Main.motors.control_x.force_control.sea_pos(0,1)
    // Iterate over ranges Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)] and Main.motors.control_x.force_control.sea_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.force_control.sea_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_x_force_control_self[dst_runtime]->_lf_sea_pos = (_ffb_controller_sea_pos_t*)&main_qdec_self[src_runtime]->_lf_sea_out[src_channel];
        }
    }
    // Connect Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)] to port Main.home.sea_pos(0,1)
    // Iterate over ranges Main.qdec.sea_out(0,1)->[Main.motors.control_x.sea_pos(0,1), Main.motors.control_x.force_control.sea_pos(0,1), Main.home.sea_pos(0,1)] and Main.home.sea_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.sea_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_sea_pos[dst_channel] = (_home_sea_pos_t*)&main_qdec_self[src_runtime]->_lf_sea_out[src_channel];
        }
    }
    // Connect Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)] to port Main.motors.control_y.sea_pos(0,1)
    // Iterate over ranges Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)] and Main.motors.control_y.sea_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_y.sea_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_y_self[dst_runtime]->_lf_sea_pos = (_sea_controllery_sea_pos_t*)&main_qdec_self[src_runtime]->_lf_sea_out[src_channel];
        }
    }
    // Connect Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)] to port Main.motors.control_y.force_control.sea_pos(0,1)
    // Iterate over ranges Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)] and Main.motors.control_y.force_control.sea_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_y.force_control.sea_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_y_force_control_self[dst_runtime]->_lf_sea_pos = (_ffb_controller_sea_pos_t*)&main_qdec_self[src_runtime]->_lf_sea_out[src_channel];
        }
    }
    // Connect Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)] to port Main.home.sea_pos(1,1)
    // Iterate over ranges Main.qdec.sea_out(1,1)->[Main.motors.control_y.sea_pos(0,1), Main.motors.control_y.force_control.sea_pos(0,1), Main.home.sea_pos(1,1)] and Main.home.sea_pos(1,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.sea_pos(1,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 1; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_sea_pos[dst_channel] = (_home_sea_pos_t*)&main_qdec_self[src_runtime]->_lf_sea_out[src_channel];
        }
    }
    // Connect Main.qdec.sea_out(2,4)->[Main.home.sea_pos(2,4)] to port Main.home.sea_pos(2,4)
    // Iterate over ranges Main.qdec.sea_out(2,4)->[Main.home.sea_pos(2,4)] and Main.home.sea_pos(2,4).
    {
        int src_start[] =  { 2, 0 };
        int src_value[] =  { 2, 0 }; // Will be incremented.
        int src_radixes[] = { 6, 1 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Main.home.sea_pos(2,4).
        {
            int range_start[] =  { 2, 0 };
            int range_radixes[] = { 6, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 2; range_count < 2 + 4; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(dst_runtime);
                int dst_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(dst_channel);
                int dst_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(dst_bank);
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = src_range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = src_range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_home_self[dst_runtime]->_lf_sea_pos[dst_channel] = (_home_sea_pos_t*)&main_qdec_self[src_runtime]->_lf_sea_out[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 2 + 4) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect inputs and outputs for reactor Main.motors.
    // Connect Main.motors.target_sel(0,6)->[Main.motors.target_sel(0,6)] to port Main.motors.target_sel(0,6)
    // Iterate over ranges Main.motors.target_sel(0,6)->[Main.motors.target_sel(0,6)] and Main.motors.target_sel(0,6).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 6, 1 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Main.motors.target_sel(0,6).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 6, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 6; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(dst_runtime);
                int dst_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(dst_channel);
                int dst_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(dst_bank);
                int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = src_range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = src_range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_motors_self[dst_runtime]->_lf_target_sel[dst_channel] = (_motor_driver_target_sel_t*)main_main_self[src_runtime]->_lf_motors.target_sel[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 6) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect Main.motors.target_speed(0,6)->[Main.motors.target_speed(0,6)] to port Main.motors.target_speed(0,6)
    // Iterate over ranges Main.motors.target_speed(0,6)->[Main.motors.target_speed(0,6)] and Main.motors.target_speed(0,6).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 6, 1 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Main.motors.target_speed(0,6).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 6, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 6; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(dst_runtime);
                int dst_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(dst_channel);
                int dst_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(dst_bank);
                int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = src_range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = src_range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_motors_self[dst_runtime]->_lf_target_speed[dst_channel] = (_motor_driver_target_speed_t*)main_main_self[src_runtime]->_lf_motors.target_speed[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 6) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)] to port Main.motors.control_x.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)] and Main.motors.control_x.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_x_self[dst_runtime]->_lf_target_pos = (_sea_controllerx_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)] to port Main.motors.control_x.pos_control.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)] and Main.motors.control_x.pos_control.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.pos_control.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_x_pos_control_self[dst_runtime]->_lf_target_pos = (_pid_controller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)] to port Main.motors.control_x.force_control.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(0,1)->[Main.motors.control_x.target_pos(0,1), Main.motors.control_x.pos_control.target_pos(0,1), Main.motors.control_x.force_control.target_pos(0,1)] and Main.motors.control_x.force_control.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.force_control.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_x_force_control_self[dst_runtime]->_lf_target_pos = (_ffb_controller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)] to port Main.motors.control_y.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)] and Main.motors.control_y.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_y.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_y_self[dst_runtime]->_lf_target_pos = (_sea_controllery_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)] to port Main.motors.control_y.pos_control.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)] and Main.motors.control_y.pos_control.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_y.pos_control.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_y_pos_control_self[dst_runtime]->_lf_target_pos = (_pid_controller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)] to port Main.motors.control_y.force_control.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(1,1)->[Main.motors.control_y.target_pos(0,1), Main.motors.control_y.pos_control.target_pos(0,1), Main.motors.control_y.force_control.target_pos(0,1)] and Main.motors.control_y.force_control.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_y.force_control.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_y_force_control_self[dst_runtime]->_lf_target_pos = (_ffb_controller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(2,1)->[Main.motors.control_z.target_pos(0,1)] to port Main.motors.control_z.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(2,1)->[Main.motors.control_z.target_pos(0,1)] and Main.motors.control_z.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 2; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_z.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_z_self[dst_runtime]->_lf_target_pos = (_pid_controller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(3,1)->[Main.motors.control_r.target_pos(0,1)] to port Main.motors.control_r.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(3,1)->[Main.motors.control_r.target_pos(0,1)] and Main.motors.control_r.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 3; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_r.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_r_self[dst_runtime]->_lf_target_pos = (_pid_controller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(4,1)->[Main.motors.control_a1.target_pos(0,1)] to port Main.motors.control_a1.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(4,1)->[Main.motors.control_a1.target_pos(0,1)] and Main.motors.control_a1.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 4; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_a1.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_a1_self[dst_runtime]->_lf_target_pos = (_pid_controller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(5,1)->[Main.motors.control_a2.target_pos(0,1)] to port Main.motors.control_a2.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(5,1)->[Main.motors.control_a2.target_pos(0,1)] and Main.motors.control_a2.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 5; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_a2.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_a2_self[dst_runtime]->_lf_target_pos = (_pid_controller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect inputs and outputs for reactor Main.motors.stepper.
    // Connect Main.motors.stepper.set_speed_0(0,1)->[Main.motors.stepper.set_speed_0(0,1)] to port Main.motors.stepper.set_speed_0(0,1)
    // Iterate over ranges Main.motors.stepper.set_speed_0(0,1)->[Main.motors.stepper.set_speed_0(0,1)] and Main.motors.stepper.set_speed_0(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.stepper.set_speed_0(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_stepper_self[dst_runtime]->_lf_set_speed_0 = (_stepper_set_speed_0_t*)&main_motors_self[src_runtime]->_lf_stepper.set_speed_0;
        }
    }
    // Connect Main.motors.stepper.set_speed_1(0,1)->[Main.motors.stepper.set_speed_1(0,1)] to port Main.motors.stepper.set_speed_1(0,1)
    // Iterate over ranges Main.motors.stepper.set_speed_1(0,1)->[Main.motors.stepper.set_speed_1(0,1)] and Main.motors.stepper.set_speed_1(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.stepper.set_speed_1(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_stepper_self[dst_runtime]->_lf_set_speed_1 = (_stepper_set_speed_1_t*)&main_motors_self[src_runtime]->_lf_stepper.set_speed_1;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.usm.
    // Connect Main.motors.usm.set_speed_2(0,1)->[Main.motors.usm.set_speed_2(0,1)] to port Main.motors.usm.set_speed_2(0,1)
    // Iterate over ranges Main.motors.usm.set_speed_2(0,1)->[Main.motors.usm.set_speed_2(0,1)] and Main.motors.usm.set_speed_2(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.usm.set_speed_2(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_usm_self[dst_runtime]->_lf_set_speed_2 = (_usm_set_speed_2_t*)&main_motors_self[src_runtime]->_lf_usm.set_speed_2;
        }
    }
    // Connect Main.motors.usm.set_speed_3(0,1)->[Main.motors.usm.set_speed_3(0,1)] to port Main.motors.usm.set_speed_3(0,1)
    // Iterate over ranges Main.motors.usm.set_speed_3(0,1)->[Main.motors.usm.set_speed_3(0,1)] and Main.motors.usm.set_speed_3(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.usm.set_speed_3(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_usm_self[dst_runtime]->_lf_set_speed_3 = (_usm_set_speed_3_t*)&main_motors_self[src_runtime]->_lf_usm.set_speed_3;
        }
    }
    // Connect Main.motors.usm.set_speed_4(0,1)->[Main.motors.usm.set_speed_4(0,1)] to port Main.motors.usm.set_speed_4(0,1)
    // Iterate over ranges Main.motors.usm.set_speed_4(0,1)->[Main.motors.usm.set_speed_4(0,1)] and Main.motors.usm.set_speed_4(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.usm.set_speed_4(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_usm_self[dst_runtime]->_lf_set_speed_4 = (_usm_set_speed_4_t*)&main_motors_self[src_runtime]->_lf_usm.set_speed_4;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_x.
    // Connect Main.motors.control_x.out(0,1)->[Main.motors.control_x.out(0,1)] to port Main.motors.control_x.out(0,1)
    // Iterate over ranges Main.motors.control_x.out(0,1)->[Main.motors.control_x.out(0,1)] and Main.motors.control_x.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_x.out = (_sea_controllerx_out_t*)&main_motors_control_x_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_x.force_control.
    // Connect Main.motors.control_x.force_control.out(0,1)->[Main.motors.control_x.force_control.out(0,1)] to port Main.motors.control_x.force_control.out(0,1)
    // Iterate over ranges Main.motors.control_x.force_control.out(0,1)->[Main.motors.control_x.force_control.out(0,1)] and Main.motors.control_x.force_control.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.force_control.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_x_self[dst_runtime]->_lf_force_control.out = (_ffb_controller_out_t*)&main_motors_control_x_force_control_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_x.pos_control.
    // Connect Main.motors.control_x.pos_control.out(0,1)->[Main.motors.control_x.pos_control.out(0,1)] to port Main.motors.control_x.pos_control.out(0,1)
    // Iterate over ranges Main.motors.control_x.pos_control.out(0,1)->[Main.motors.control_x.pos_control.out(0,1)] and Main.motors.control_x.pos_control.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_x.pos_control.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_x_self[dst_runtime]->_lf_pos_control.out = (_pid_controller_out_t*)&main_motors_control_x_pos_control_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_y.
    // Connect Main.motors.control_y.out(0,1)->[Main.motors.control_y.out(0,1)] to port Main.motors.control_y.out(0,1)
    // Iterate over ranges Main.motors.control_y.out(0,1)->[Main.motors.control_y.out(0,1)] and Main.motors.control_y.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_y.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_y.out = (_sea_controllery_out_t*)&main_motors_control_y_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_y.force_control.
    // Connect Main.motors.control_y.force_control.out(0,1)->[Main.motors.control_y.force_control.out(0,1)] to port Main.motors.control_y.force_control.out(0,1)
    // Iterate over ranges Main.motors.control_y.force_control.out(0,1)->[Main.motors.control_y.force_control.out(0,1)] and Main.motors.control_y.force_control.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_y.force_control.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_y_self[dst_runtime]->_lf_force_control.out = (_ffb_controller_out_t*)&main_motors_control_y_force_control_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_y.pos_control.
    // Connect Main.motors.control_y.pos_control.out(0,1)->[Main.motors.control_y.pos_control.out(0,1)] to port Main.motors.control_y.pos_control.out(0,1)
    // Iterate over ranges Main.motors.control_y.pos_control.out(0,1)->[Main.motors.control_y.pos_control.out(0,1)] and Main.motors.control_y.pos_control.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_y.pos_control.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_y_self[dst_runtime]->_lf_pos_control.out = (_pid_controller_out_t*)&main_motors_control_y_pos_control_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_z.
    // Connect Main.motors.control_z.out(0,1)->[Main.motors.control_z.out(0,1)] to port Main.motors.control_z.out(0,1)
    // Iterate over ranges Main.motors.control_z.out(0,1)->[Main.motors.control_z.out(0,1)] and Main.motors.control_z.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_z.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_z.out = (_pid_controller_out_t*)&main_motors_control_z_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_r.
    // Connect Main.motors.control_r.out(0,1)->[Main.motors.control_r.out(0,1)] to port Main.motors.control_r.out(0,1)
    // Iterate over ranges Main.motors.control_r.out(0,1)->[Main.motors.control_r.out(0,1)] and Main.motors.control_r.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_r.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_r.out = (_pid_controller_out_t*)&main_motors_control_r_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_a1.
    // Connect Main.motors.control_a1.out(0,1)->[Main.motors.control_a1.out(0,1)] to port Main.motors.control_a1.out(0,1)
    // Iterate over ranges Main.motors.control_a1.out(0,1)->[Main.motors.control_a1.out(0,1)] and Main.motors.control_a1.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_a1.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_a1.out = (_pid_controller_out_t*)&main_motors_control_a1_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_a2.
    // Connect Main.motors.control_a2.out(0,1)->[Main.motors.control_a2.out(0,1)] to port Main.motors.control_a2.out(0,1)
    // Iterate over ranges Main.motors.control_a2.out(0,1)->[Main.motors.control_a2.out(0,1)] and Main.motors.control_a2.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_a2.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_a2.out = (_pid_controller_out_t*)&main_motors_control_a2_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.home.
    // Connect Main.home.motor_speed(0,6)->[Main.home.motor_speed(0,6)] to port Main.home.motor_speed(0,6)
    // Iterate over ranges Main.home.motor_speed(0,6)->[Main.home.motor_speed(0,6)] and Main.home.motor_speed(0,6).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 6, 1 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Main.home.motor_speed(0,6).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 6, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 6; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(dst_runtime);
                int dst_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(dst_channel);
                int dst_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(dst_bank);
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = src_range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = src_range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_main_self[dst_runtime]->_lf_home.motor_speed[dst_channel] = (_home_motor_speed_t*)&main_home_self[src_runtime]->_lf_motor_speed[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 6) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect inputs and outputs for reactor Main.home.homing_switches.
    // Connect Main.home.homing_switches.read(0,6)->[Main.home.homing_switches.read(0,6)] to port Main.home.homing_switches.read(0,6)
    // Iterate over ranges Main.home.homing_switches.read(0,6)->[Main.home.homing_switches.read(0,6)] and Main.home.homing_switches.read(0,6).
    {
        int src_start[] =  { 0, 0, 0 };
        int src_value[] =  { 0, 0, 0 }; // Will be incremented.
        int src_radixes[] = { 6, 1, 1 };
        int src_permutation[] = { 0, 1, 2 };
        mixed_radix_int_t src_range_mr = {
            3,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Main.home.homing_switches.read(0,6).
        {
            int range_start[] =  { 0, 0, 0 };
            int range_radixes[] = { 6, 1, 1 };
            int permutation[] = { 0, 1, 2 };
            mixed_radix_int_t range_mr = {
                3,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 6; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(dst_runtime);
                int dst_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(dst_channel);
                int dst_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(dst_bank);
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = src_range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = src_range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_home_self[dst_runtime]->_lf_homing_switches.read[dst_channel] = (_switches_read_t*)&main_home_homing_switches_self[src_runtime]->_lf_read[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 6) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    {
    }
    {
        {
        }
        {
        }
        {
            {
            }
            {
            }
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    // Add port Main.motors.control_x.force_control.out to array of is_present fields.
                    envs[main_main].is_present_fields[0 + count] = &main_motors_control_x_force_control_self[0]->_lf_out.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    // Add port Main.motors.control_x.force_control.out to array of intended_tag fields.
                    envs[main_main]._lf_intended_tag_fields[0 + count] = &main_motors_control_x_force_control_self[0]->_lf_out.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    // Add port Main.motors.control_x.pos_control.out to array of is_present fields.
                    envs[main_main].is_present_fields[1 + count] = &main_motors_control_x_pos_control_self[0]->_lf_out.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    // Add port Main.motors.control_x.pos_control.out to array of intended_tag fields.
                    envs[main_main]._lf_intended_tag_fields[1 + count] = &main_motors_control_x_pos_control_self[0]->_lf_out.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        {
            {
            }
            {
            }
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    // Add port Main.motors.control_y.force_control.out to array of is_present fields.
                    envs[main_main].is_present_fields[2 + count] = &main_motors_control_y_force_control_self[0]->_lf_out.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    // Add port Main.motors.control_y.force_control.out to array of intended_tag fields.
                    envs[main_main]._lf_intended_tag_fields[2 + count] = &main_motors_control_y_force_control_self[0]->_lf_out.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    // Add port Main.motors.control_y.pos_control.out to array of is_present fields.
                    envs[main_main].is_present_fields[3 + count] = &main_motors_control_y_pos_control_self[0]->_lf_out.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    // Add port Main.motors.control_y.pos_control.out to array of intended_tag fields.
                    envs[main_main]._lf_intended_tag_fields[3 + count] = &main_motors_control_y_pos_control_self[0]->_lf_out.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        {
        }
        {
        }
        {
        }
        {
        }
        // Add port Main.motors.stepper.set_speed_0 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[4 + count] = &main_motors_self[0]->_lf_stepper.set_speed_0.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[4 + count] = &main_motors_self[0]->_lf_stepper.set_speed_0.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        // Add port Main.motors.stepper.set_speed_1 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[5 + count] = &main_motors_self[0]->_lf_stepper.set_speed_1.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[5 + count] = &main_motors_self[0]->_lf_stepper.set_speed_1.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        // Add port Main.motors.usm.set_speed_2 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[6 + count] = &main_motors_self[0]->_lf_usm.set_speed_2.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[6 + count] = &main_motors_self[0]->_lf_usm.set_speed_2.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        // Add port Main.motors.usm.set_speed_3 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[7 + count] = &main_motors_self[0]->_lf_usm.set_speed_3.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[7 + count] = &main_motors_self[0]->_lf_usm.set_speed_3.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        // Add port Main.motors.usm.set_speed_4 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[8 + count] = &main_motors_self[0]->_lf_usm.set_speed_4.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[8 + count] = &main_motors_self[0]->_lf_usm.set_speed_4.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add port Main.motors.control_x.out to array of is_present fields.
                envs[main_main].is_present_fields[9 + count] = &main_motors_control_x_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add port Main.motors.control_x.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[9 + count] = &main_motors_control_x_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add port Main.motors.control_y.out to array of is_present fields.
                envs[main_main].is_present_fields[10 + count] = &main_motors_control_y_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add port Main.motors.control_y.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[10 + count] = &main_motors_control_y_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add port Main.motors.control_z.out to array of is_present fields.
                envs[main_main].is_present_fields[11 + count] = &main_motors_control_z_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add port Main.motors.control_z.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[11 + count] = &main_motors_control_z_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add port Main.motors.control_r.out to array of is_present fields.
                envs[main_main].is_present_fields[12 + count] = &main_motors_control_r_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add port Main.motors.control_r.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[12 + count] = &main_motors_control_r_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add port Main.motors.control_a1.out to array of is_present fields.
                envs[main_main].is_present_fields[13 + count] = &main_motors_control_a1_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add port Main.motors.control_a1.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[13 + count] = &main_motors_control_a1_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add port Main.motors.control_a2.out to array of is_present fields.
                envs[main_main].is_present_fields[14 + count] = &main_motors_control_a2_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add port Main.motors.control_a2.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[14 + count] = &main_motors_control_a2_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
    }
    {
        {
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add port Main.home.homing_switches.read to array of is_present fields.
                // Port Main.home.homing_switches.read is a multiport. Iterate over its channels.
                for (int main_home_homing_switches_read_c = 0; main_home_homing_switches_read_c < 6; main_home_homing_switches_read_c++) {
                    envs[main_main].is_present_fields[15 + count] = &main_home_homing_switches_self[0]->_lf_read[main_home_homing_switches_read_c].is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    // Add port Main.home.homing_switches.read to array of intended_tag fields.
                    envs[main_main]._lf_intended_tag_fields[15 + count] = &main_home_homing_switches_self[0]->_lf_read[main_home_homing_switches_read_c].intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
    }
    // Add port Main.motors.target_pos to array of is_present fields.
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            {
                // Port Main.motors.target_pos is a multiport. Iterate over its channels.
                for (int main_motors_target_pos_c = 0; main_motors_target_pos_c < 6; main_motors_target_pos_c++) {
                    envs[main_main].is_present_fields[21 + count] = &main_main_self[0]->_lf_motors.target_pos[main_motors_target_pos_c]->is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[21 + count] = &main_main_self[0]->_lf_motors.target_pos[main_motors_target_pos_c]->intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
    }
    // Add port Main.qdec.reset_qdec to array of is_present fields.
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            {
                envs[main_main].is_present_fields[27 + count] = &main_main_self[0]->_lf_qdec.reset_qdec.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                envs[main_main]._lf_intended_tag_fields[27 + count] = &main_main_self[0]->_lf_qdec.reset_qdec.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
    }
    // Add port Main.motors.target_sel to array of is_present fields.
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            {
                // Port Main.motors.target_sel is a multiport. Iterate over its channels.
                for (int main_motors_target_sel_c = 0; main_motors_target_sel_c < 6; main_motors_target_sel_c++) {
                    envs[main_main].is_present_fields[28 + count] = &main_main_self[0]->_lf_motors.target_sel[main_motors_target_sel_c]->is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[28 + count] = &main_main_self[0]->_lf_motors.target_sel[main_motors_target_sel_c]->intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
    }
    // Add port Main.motors.target_speed to array of is_present fields.
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            {
                // Port Main.motors.target_speed is a multiport. Iterate over its channels.
                for (int main_motors_target_speed_c = 0; main_motors_target_speed_c < 6; main_motors_target_speed_c++) {
                    envs[main_main].is_present_fields[34 + count] = &main_main_self[0]->_lf_motors.target_speed[main_motors_target_speed_c]->is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[34 + count] = &main_main_self[0]->_lf_motors.target_speed[main_motors_target_speed_c]->intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            // Add port Main.qdec.qdec_out to array of is_present fields.
            // Port Main.qdec.qdec_out is a multiport. Iterate over its channels.
            for (int main_qdec_qdec_out_c = 0; main_qdec_qdec_out_c < 6; main_qdec_qdec_out_c++) {
                envs[main_main].is_present_fields[40 + count] = &main_qdec_self[0]->_lf_qdec_out[main_qdec_qdec_out_c].is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add port Main.qdec.qdec_out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[40 + count] = &main_qdec_self[0]->_lf_qdec_out[main_qdec_qdec_out_c].intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
            // Add port Main.qdec.sea_out to array of is_present fields.
            // Port Main.qdec.sea_out is a multiport. Iterate over its channels.
            for (int main_qdec_sea_out_c = 0; main_qdec_sea_out_c < 6; main_qdec_sea_out_c++) {
                envs[main_main].is_present_fields[40 + count] = &main_qdec_self[0]->_lf_sea_out[main_qdec_sea_out_c].is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add port Main.qdec.sea_out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[40 + count] = &main_qdec_self[0]->_lf_sea_out[main_qdec_sea_out_c].intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            // Add port Main.home.motor_speed to array of is_present fields.
            // Port Main.home.motor_speed is a multiport. Iterate over its channels.
            for (int main_home_motor_speed_c = 0; main_home_motor_speed_c < 6; main_home_motor_speed_c++) {
                envs[main_main].is_present_fields[52 + count] = &main_home_self[0]->_lf_motor_speed[main_home_motor_speed_c].is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add port Main.home.motor_speed to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[52 + count] = &main_home_self[0]->_lf_motor_speed[main_home_motor_speed_c].intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
    }
    
    // Set reaction priorities for ReactorInstance Main
    {
        // index is the OR of level 0 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
        // index is the OR of level 1 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 1);
        // index is the OR of level 2 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 2);
        // index is the OR of level 6 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_3.index = lf_combine_deadline_and_level(9223372036854775807, 6);
        // index is the OR of level 7 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_4.index = lf_combine_deadline_and_level(9223372036854775807, 7);
        // index is the OR of level 8 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_5.index = lf_combine_deadline_and_level(9223372036854775807, 8);
    
        // Set reaction priorities for ReactorInstance Main.qdec
        {
            // index is the OR of level 0 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_qdec_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
            // index is the OR of level 3 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_qdec_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 3);
            // index is the OR of level 4 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_qdec_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 4);
        }
    
    
        // Set reaction priorities for ReactorInstance Main.motors
        {
            // index is the OR of level 7 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_motors_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 7);
            // index is the OR of level 9 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_motors_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 9);
            // index is the OR of level 10 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_motors_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 10);
        
            // Set reaction priorities for ReactorInstance Main.motors.stepper
            {
                // index is the OR of level 0 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_stepper_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
                // index is the OR of level 11 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_stepper_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 11);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.usm
            {
                // index is the OR of level 0 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_usm_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
                // index is the OR of level 11 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_usm_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 11);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_x
            {
                // index is the OR of level 5 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_x_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
                // index is the OR of level 6 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_x_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 6);
            
                // Set reaction priorities for ReactorInstance Main.motors.control_x.force_control
                {
                    // index is the OR of level 5 and 
                    // deadline 9223372036854775807 shifted left 16 bits.
                    main_motors_control_x_force_control_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
                }
            
            
                // Set reaction priorities for ReactorInstance Main.motors.control_x.pos_control
                {
                    // index is the OR of level 5 and 
                    // deadline 9223372036854775807 shifted left 16 bits.
                    main_motors_control_x_pos_control_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
                }
            
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_y
            {
                // index is the OR of level 5 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_y_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
                // index is the OR of level 6 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_y_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 6);
            
                // Set reaction priorities for ReactorInstance Main.motors.control_y.force_control
                {
                    // index is the OR of level 5 and 
                    // deadline 9223372036854775807 shifted left 16 bits.
                    main_motors_control_y_force_control_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
                }
            
            
                // Set reaction priorities for ReactorInstance Main.motors.control_y.pos_control
                {
                    // index is the OR of level 5 and 
                    // deadline 9223372036854775807 shifted left 16 bits.
                    main_motors_control_y_pos_control_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
                }
            
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_z
            {
                // index is the OR of level 5 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_z_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_r
            {
                // index is the OR of level 5 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_r_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_a1
            {
                // index is the OR of level 5 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_a1_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_a2
            {
                // index is the OR of level 5 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_a2_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
            }
        
        }
    
    
        // Set reaction priorities for ReactorInstance Main.home
        {
            // index is the OR of level 5 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_home_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
        
            // Set reaction priorities for ReactorInstance Main.home.homing_switches
            {
                // index is the OR of level 0 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_home_homing_switches_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
                // index is the OR of level 1 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_home_homing_switches_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 1);
            }
        
        }
    
    }
    

    #ifdef EXECUTABLE_PREAMBLE
    _lf_executable_preamble(&envs[0]);
    #endif
    #ifdef FEDERATED
    initialize_triggers_for_federate();
    #endif // FEDERATED
}
void logical_tag_complete(tag_t tag_to_send) {
 #ifdef FEDERATED_CENTRALIZED
     lf_latest_tag_confirmed(tag_to_send);
 #else
     (void) tag_to_send;
 #endif // FEDERATED_CENTRALIZED

}
#ifndef FEDERATED
void lf_terminate_execution(environment_t* env) {
    (void) env;
}
#endif
